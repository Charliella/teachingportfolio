<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å°ç¨±ç¹ªåœ– - å¹³æ¿ä¿®æ­£ç‰ˆ</title>
    <style>
        /* --- æ•´é«”å¤œé–“æ¨¡å¼æ¨£å¼ --- */
        body {
            font-family: 'Arial', sans-serif;
            text-align: center;
            padding: 20px;
            margin: 0;
            background-color: #1a1a2e; 
            color: #e9f1f8; 
            /* é˜²æ­¢æ‰‹æ©Ÿä¸Šé•·æŒ‰é¸å–æ–‡å­— */
            user-select: none;
            -webkit-user-select: none;
            overflow-x: hidden; /* é˜²æ­¢å·¦å³æ»‘å‹• */
            touch-action: none; /* é—œéµï¼šç¦æ­¢ç€è¦½å™¨é è¨­è§¸æ§è¡Œç‚º */
        }
        h1 {
            color: #00ffc4; 
            text-shadow: 0 0 5px #00ffc4;
            font-size: 1.5rem;
            margin: 10px 0;
        }
        #statusText {
            color: #99ffff; 
            font-size: 1rem;
            font-weight: bold;
            min-height: 1.2em;
            margin-bottom: 10px;
        }
        #drawingCanvas {
            width: 95%; 
            max-width: 800px;
            height: 500px; /* CSS é¡¯ç¤ºé«˜åº¦ */
            border: 2px solid #00ffc4; 
            background-color: #0d0d1a; 
            cursor: crosshair; 
            margin: 0 auto;
            display: block; 
            /* é—œéµï¼šå‘Šè¨´ç€è¦½å™¨é€™å€‹å€åŸŸç”±ç¨‹å¼æ¥ç®¡è§¸æ§ */
            touch-action: none; 
            box-shadow: 0 0 15px rgba(0, 255, 196, 0.5); 
            border-radius: 8px;
        }
        /* --- æŒ‰éˆ•æ¨£å¼ --- */
        .controls { 
            margin-bottom: 15px; 
            display: flex; 
            justify-content: center; 
            flex-wrap: wrap; 
            gap: 8px; 
            padding: 0 10px;
        }
        .controls button {
            padding: 10px 20px;
            font-size: 15px;
            cursor: pointer;
            border: 2px solid;
            border-radius: 4px;
            transition: all 0.2s;
            box-shadow: 0 0 5px;
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.1);
            white-space: nowrap; /* é˜²æ­¢æ–‡å­—æ›è¡Œ */
        }
        
        /* å„éšæ®µæŒ‰éˆ•é¡è‰² */
        #setAxisButton { color: #ff9900; border-color: #ff9900; box-shadow: 0 0 5px #ff9900; }
        #startRedDrawButton { color: #ff33cc; border-color: #ff33cc; box-shadow: 0 0 5px #ff33cc; display: none; }
        #startBlueDrawButton { color: #33ccff; border-color: #33ccff; box-shadow: 0 0 5px #33ccff; display: none; }
        #compareButton { color: #00ffc4; border-color: #00ffc4; box-shadow: 0 0 5px #00ffc4; display: none; }
        #clearButton { color: #ff66ff; border-color: #ff66ff; box-shadow: 0 0 5px #ff66ff; } 

        .controls button:active { transform: scale(0.95); opacity: 0.8; }
        
        /* åœ–ä¾‹èªªæ˜ */
        .legend {
            font-size: 1em;
            margin-top: 15px;
            color: #aaa;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .legend span { display: flex; align-items: center; gap: 5px; }
    </style>
</head>
<body>

    <h1>å°ç¨±ç¹ªåœ– :: å¹³æ¿å„ªåŒ–ç‰ˆ</h1>
    <p id="statusText">ğŸ“Š æ­¥é©Ÿ 1ï¼šè«‹é»æ“Šã€Œè¨­å®šå°ç¨±è»¸ã€æŒ‰éˆ•ã€‚</p>

    <div class="controls">
        <button id="setAxisButton">ğŸ“Œ è¨­å®šå°ç¨±è»¸ (1/2)</button>
        <button id="startRedDrawButton">ğŸ–ï¸ ç´…ç­†ï¼šç¹ªè£½é¡Œç›®</button>
        <button id="startBlueDrawButton">ğŸ–Šï¸ è—ç­†ï¼šå­¸ç”Ÿä½œç­”</button>
        <button id="compareButton">ğŸ‘€ é¡¯ç¤ºæ­£ç¢ºç­”æ¡ˆæ¯”å°</button>
        <button id="clearButton">ğŸ—‘ï¸ é‡è¨­</button>
    </div>

    <canvas id="drawingCanvas"></canvas>
    
    <div class="legend" id="legend" style="display:none;">
        <span style="color:#ff33cc">ğŸ”´ é¡Œç›®</span>
        <span style="color:#33ccff">ğŸ”µ å­¸ç”Ÿä½œç­”</span>
        <span style="color:#ffd700; font-weight:bold; text-shadow: 0 0 5px #ffd700;">ğŸŸ¡ æ­£ç¢ºç­”æ¡ˆ (é–ƒçˆ)</span>
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        
        const setAxisButton = document.getElementById('setAxisButton');
        const startRedDrawButton = document.getElementById('startRedDrawButton');
        const startBlueDrawButton = document.getElementById('startBlueDrawButton');
        const compareButton = document.getElementById('compareButton'); 
        const clearButton = document.getElementById('clearButton');
        const statusText = document.getElementById('statusText');
        const legend = document.getElementById('legend');

        // --- ç‹€æ…‹è®Šæ•¸ ---
        let currentMode = 'IDLE'; 
        let isDrawing = false;
        let symmetryP1 = null; 
        let symmetryP2 = null; 
        let angle = 0;         
        let lastX = 0, lastY = 0;
        
        // --- ç¹ªåœ–æ­·å² ---
        let redDrawingHistory = [];  
        let blueDrawingHistory = []; 
        let mirrorDrawingHistory = []; 

        let animationFrameId = null; 
        let flickerState = 0;        

        // --- é¡è‰²è¨­å®š ---
        const COLORS = {
            RED: '#ff33cc',   
            BLUE: '#33ccff',  
            GOLD: '#ffd700',  
            AXIS: '#00ffc4',  
            AXIS_LIGHT: '#99ffff' 
        };

        // --- æ ¸å¿ƒï¼šç•«å¸ƒå°ºå¯¸èˆ‡è§£æåº¦è¨­å®š (å¹³æ¿ä¿®æ­£é—œéµ) ---
        function setCanvasSize() {
            const dpr = window.devicePixelRatio || 1;
            // å–å¾— CSS é¡¯ç¤ºå¤§å°
            const rect = canvas.getBoundingClientRect();
            
            // è¨­å®šç•«å¸ƒçš„å¯¦éš›åƒç´ å¤§å° (è§£æ±º Retina æ¨¡ç³Šå•é¡Œ)
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            // å°‡ Context ç¸®æ”¾ï¼Œè®“æˆ‘å€‘å¯ä»¥ä½¿ç”¨ CSS åƒç´ åº§æ¨™é€²è¡Œç¹ªåœ–
            ctx.scale(dpr, dpr);
            
            // å› ç‚º Canvas é‡è¨­å¤§å°æœƒæ¸…ç©ºç‹€æ…‹ï¼Œéœ€è«‹æ±‚é‡ç¹ª
            if (symmetryP1 || redDrawingHistory.length > 0) {
                // ä¸éœ€è¦é¡å¤–å‘¼å« redrawï¼Œå› ç‚º animationLoop æœƒè™•ç†
            }
        }

        // --- åº§æ¨™å–å¾— (å¹³æ¿ä¿®æ­£é—œéµï¼šçµ±ä¸€æ»‘é¼ èˆ‡è§¸æ§) ---
        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            // åˆ¤æ–·æ˜¯è§¸æ§äº‹ä»¶é‚„æ˜¯æ»‘é¼ äº‹ä»¶
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else if (e.changedTouches && e.changedTouches.length > 0) {
                // è™•ç† touchend æœ‰æ™‚åœ¨ changedTouches è£¡
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            return { 
                x: clientX - rect.left, 
                y: clientY - rect.top 
            };
        }

        // --- è¼”åŠ©ï¼šé‡è¨­ç­†åˆ· ---
        function resetContext(color, width = 5, alpha = 1.0, dash = []) {
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.globalAlpha = alpha;
            ctx.setLineDash(dash);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 0;
        }

        // --- æ ¸å¿ƒï¼šé‡ç¹ªç•«å¸ƒæ‰€æœ‰å…§å®¹ ---
        function redrawAllStrokes() {
            // 1. ç¹ªè£½ç´…ç·š (é¡Œç›®)
            resetContext(COLORS.RED, 5, 1.0);
            ctx.beginPath();
            redDrawingHistory.forEach(seg => {
                ctx.moveTo(seg.x1, seg.y1);
                ctx.lineTo(seg.x2, seg.y2);
            });
            ctx.stroke();

            // 2. ç¹ªè£½è—ç·š (å­¸ç”Ÿ)
            resetContext(COLORS.BLUE, 5, 1.0);
            ctx.beginPath();
            blueDrawingHistory.forEach(seg => {
                ctx.moveTo(seg.x1, seg.y1);
                ctx.lineTo(seg.x2, seg.y2);
            });
            ctx.stroke();

            // 3. æ¯”å°æ¨¡å¼ï¼šç¹ªè£½æ­£ç¢ºç­”æ¡ˆ (é‡‘è‰²å¯¦ç·š + å‘¼å¸ç‡ˆ)
            if (currentMode === 'COMPARE' && mirrorDrawingHistory.length > 0) {
                const time = Date.now() / 800; 
                const pulse = (Math.sin(time) + 1) / 2; 
                const currentAlpha = 0.15 + (0.65 * pulse); 

                resetContext(COLORS.GOLD, 6, currentAlpha, []); 
                
                ctx.shadowColor = COLORS.GOLD;
                ctx.shadowBlur = 15 * pulse; 
                
                ctx.beginPath();
                mirrorDrawingHistory.forEach(seg => {
                    ctx.moveTo(seg.x1, seg.y1); 
                    ctx.lineTo(seg.x2, seg.y2);
                });
                ctx.stroke();
                ctx.shadowBlur = 0; 
            }
        }

        // --- ç¹ªè£½é–ƒçˆè»¸ç·š ---
        function drawSymmetryLine() {
            if (!symmetryP1 || !symmetryP2) return;

            flickerState = (flickerState + 1) % 60; 
            const isFlicker = (flickerState % 15 < 3);
            
            resetContext(
                isFlicker ? COLORS.AXIS_LIGHT : COLORS.AXIS,
                isFlicker ? 2 : 1.5,
                isFlicker ? 0.9 : 0.6,
                [(flickerState % 10) + 5, 5]
            );
            
            ctx.beginPath();
            ctx.moveTo(symmetryP1.x, symmetryP1.y);
            ctx.lineTo(symmetryP2.x, symmetryP2.y);
            ctx.stroke();
            ctx.setLineDash([]);

            // ç•«ç«¯é»
            const drawPoint = (p, color) => {
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = color;
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
                ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
            };
            drawPoint(symmetryP1, '#ff33cc');
            drawPoint(symmetryP2, '#ff9900');
        }

        // --- å‹•ç•«å¾ªç’° ---
        function animationLoop() {
            ctx.clearRect(0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
            redrawAllStrokes(); 
            drawSymmetryLine();
            animationFrameId = requestAnimationFrame(animationLoop);
        }

        function startAnimation() {
            if (!animationFrameId) animationLoop();
        }
        function stopAnimation() {
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
        }

        // --- å¹¾ä½•è¨ˆç®— ---
        function getMirrorPoint(x, y) {
            if (!symmetryP1 || !symmetryP2) return {x, y};
            const x1 = symmetryP1.x, y1 = symmetryP1.y;
            const cosA = Math.cos(angle), sinA = Math.sin(angle);
            const tx = x - x1, ty = y - y1;
            const rx = tx * cosA + ty * sinA;
            const ry = ty * cosA - tx * sinA;
            const finalX = (rx * cosA - (-ry) * sinA) + x1;
            const finalY = (rx * sinA + (-ry) * cosA) + y1;
            return { x: finalX, y: finalY };
        }

        // --- ç¹ªåœ–è™•ç† ---
        function handleStart(x, y) {
             if (currentMode === 'SET_P1') {
                symmetryP1 = {x, y};
                currentMode = 'SET_P2';
                setAxisButton.textContent = 'è¨­å®šé» 2...';
                // ç«‹å³å›é¥‹
                ctx.fillStyle = '#ff33cc'; ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.fill();
            } else if (currentMode === 'SET_P2') {
                symmetryP2 = {x, y};
                angle = Math.atan2(symmetryP2.y - symmetryP1.y, symmetryP2.x - symmetryP1.x);
                currentMode = 'IDLE';
                setAxisButton.textContent = 'âœ… è»¸ç·šå·²è¨­å®š';
                setAxisButton.style.backgroundColor = '#17a2b8';
                startAnimation(); 
                statusText.textContent = 'è»¸ç·šå®Œæˆï¼è«‹æŒ‰ã€Œç´…ç­†ã€é–‹å§‹å‡ºé¡Œã€‚';
            } else if (currentMode === 'DRAW_RED' || currentMode === 'DRAW_BLUE') {
                isDrawing = true;
                [lastX, lastY] = [x, y];
            }
        }

        function handleMove(x, y) {
            if (!isDrawing) return;
            let history = (currentMode === 'DRAW_RED') ? redDrawingHistory : blueDrawingHistory;
            history.push({ x1: lastX, y1: lastY, x2: x, y2: y });
            [lastX, lastY] = [x, y];
        }

        function handleEnd() {
            isDrawing = false;
        }

        // --- äº‹ä»¶ç›£è½ (æ•´åˆæ»‘é¼ èˆ‡è§¸æ§) ---
        
        // Pointer Down (Mouse Down / Touch Start)
        const onPointerDown = (e) => {
            // å¦‚æœé»æ“Šçš„æ˜¯æŒ‰éˆ•ï¼Œä¸è¦è§¸ç™¼ Canvas äº‹ä»¶
            if (e.target !== canvas) return;
            
            e.preventDefault(); // é˜²æ­¢åœ¨å¹³æ¿ä¸Šæ²å‹•æˆ–ç¸®æ”¾
            const {x, y} = getCoords(e);
            handleStart(x, y);
        };

        // Pointer Move (Mouse Move / Touch Move)
        const onPointerMove = (e) => {
             if (e.target !== canvas && !isDrawing) return;
             
             e.preventDefault(); // é˜²æ­¢æ‹–æ›³é é¢
             const {x, y} = getCoords(e);
             handleMove(x, y);
        };

        // Pointer Up (Mouse Up / Touch End)
        const onPointerUp = (e) => {
            handleEnd();
        };

        // è¨»å†Šç›£è½å™¨
        canvas.addEventListener('mousedown', onPointerDown);
        canvas.addEventListener('touchstart', onPointerDown, {passive: false});

        canvas.addEventListener('mousemove', onPointerMove);
        canvas.addEventListener('touchmove', onPointerMove, {passive: false});

        window.addEventListener('mouseup', onPointerUp);
        window.addEventListener('touchend', onPointerUp);

        // --- æŒ‰éˆ•é‚è¼¯ ---
        setAxisButton.onclick = () => {
            currentMode = 'SET_P1';
            isDrawing = false;
            mirrorDrawingHistory = [];
            legend.style.display = 'none';
            
            startRedDrawButton.style.display = 'block';
            startBlueDrawButton.style.display = 'none';
            compareButton.style.display = 'none';
            
            setAxisButton.textContent = 'è¨­å®šé» 1...';
            statusText.textContent = 'æ­¥é©Ÿ 1ï¼šè«‹é»æ“Šç•«å¸ƒè¨­å®šç¬¬ä¸€å€‹è»¸é»ã€‚';
            
            // æ¸…é™¤ä¸¦é‡è¨­å°ºå¯¸ (è§£æ±ºæ®˜ç•™å•é¡Œ)
            stopAnimation();
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            // å› ç‚ºå‹•ç•«åœæ­¢äº†ï¼Œé€™è£¡ä¸å¼·åˆ¶é‡ç¹ªï¼Œç­‰å¾…ç¬¬ä¸€æ¬¡é»æ“Š
        };

        startRedDrawButton.onclick = () => {
            if (!symmetryP1 || !symmetryP2) { alert("è«‹å…ˆè¨­å®šè»¸ç·šï¼"); return; }
            currentMode = 'DRAW_RED';
            statusText.textContent = 'ğŸ–ï¸ ç´…ç­†æ¨¡å¼ï¼šè«‹ç¹ªè£½é¡Œç›®ç·šæ¢ (å–®å´)ã€‚';
            startRedDrawButton.style.display = 'none';
            startBlueDrawButton.style.display = 'block';
        };

        startBlueDrawButton.onclick = () => {
            currentMode = 'DRAW_BLUE';
            statusText.textContent = 'ğŸ–Šï¸ è—ç­†æ¨¡å¼ï¼šè«‹ç¹ªè£½é¡åƒç­”æ¡ˆã€‚';
            startBlueDrawButton.style.display = 'none';
            compareButton.style.display = 'block'; 
        };

        compareButton.onclick = () => {
            if (redDrawingHistory.length === 0) { alert("è«‹å…ˆç•«ç´…ç·šé¡Œç›®ï¼"); return; }
            if (blueDrawingHistory.length === 0) { alert("å­¸ç”Ÿé‚„æ²’ä½œç­”å–”ï¼"); return; }

            currentMode = 'COMPARE';
            legend.style.display = 'flex';
            
            mirrorDrawingHistory = redDrawingHistory.map(seg => {
                const p1 = getMirrorPoint(seg.x1, seg.y1);
                const p2 = getMirrorPoint(seg.x2, seg.y2);
                return { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y };
            });

            statusText.textContent = 'ğŸ‘€ æ¯”å°æ¨¡å¼ï¼šé‡‘è‰²å¯¦ç·šæœƒæ…¢æ…¢é–ƒçˆï¼Œè«‹æª¢æŸ¥å­¸ç”Ÿç­”æ¡ˆæ˜¯å¦é‡ç–Šã€‚';
            compareButton.style.display = 'none';
        };

        clearButton.onclick = () => {
            location.reload(); 
        };

        // åˆå§‹åŒ–èˆ‡èª¿æ•´è¦–çª—
        window.onload = setCanvasSize;
        window.onresize = setCanvasSize;

    </script>
</body>
</html>