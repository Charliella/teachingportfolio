<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Math Slash - æ•¸å­¸ä¹‹åˆƒ (Cyberpunk ç‰ˆ)</title>
    <style>
        /* å¼•å…¥é»é™£å­—é«”å’Œç¹é«”ä¸­æ–‡é»‘é«” */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Noto+Serif+TC:wght@900&display=swap');

        /* Cyberpunk Color Palette */
        :root {
            --bg-color: #0b0f14;
            --hud-bg: #1e2531;
            --hud-border: #00ffff; /* éœ“è™¹é’è‰² */
            --accent-color: #ff00ff; /* éœ“è™¹æ´‹ç´… */
            --text-highlight: #fffa50; /* é›»å…‰é»ƒ */
            --danger-color: #ff3333;
            --font-main: 'Press Start 2P', cursive;
            --font-title: 'Noto Serif TC', serif;
        }

        /* ç¢ºä¿å…¨è¢å¹•ä¸”ç„¡æ²è»¸ */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--font-main);
            touch-action: none; /* ç¦æ­¢æ‰‹æ©Ÿä¸Šçš„é è¨­æ‰‹å‹¢ */
            user-select: none;
            -webkit-user-select: none;
        }

        /* ğŸ† å€å¡Šå®¹å™¨ï¼šä½¿ç”¨ Flexbox å‚ç›´åˆ‡åˆ†ç•«é¢ */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: var(--bg-color);
            display: flex;
            flex-direction: column; 
            box-sizing: border-box;
        }

        /* ğŸ¯ å€å¡Šä¸€ï¼šä¸Šå±¤ HUD ä»‹é¢ (æ‰€æœ‰æ•¸å€¼é¡¯ç¤ºå€) */
        #doom-hud {
            width: 100%;
            height: 10vh; /* åŸºç¤é«˜åº¦æ¯”ä¾‹ */
            max-height: 90px; 
            background: var(--hud-bg);
            border-bottom: 3px solid var(--hud-border); 
            
            /* æ©«å‘æƒæç·šæ•ˆæœ */
            background-image: linear-gradient(rgba(0,0,0,0.5) 1px, transparent 1px);
            background-size: 100% 4px; 
            
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            z-index: 10;
            box-shadow: 0 0 15px var(--accent-color);
            padding: 2px 0; 
            box-sizing: border-box;
            flex-shrink: 0; 
        }

        /* ğŸ–¼ï¸ å€å¡ŠäºŒï¼šä¸‹å±¤ Canvas éŠæˆ²å€ (å€™é¸äººæ¼‚æµ®å€) */
        canvas {
            display: block;
            flex-grow: 1; 
            width: 100%;
            cursor: crosshair;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        /* ---------------------------------------------------- */
        /* HUD å…§éƒ¨æ¨£å¼ (ç¢ºä¿éŸ¿æ‡‰å¼å­—é«”ä¸æº¢å‡º) */
        /* ---------------------------------------------------- */

        .hud-panel {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--hud-border);
            /* é‚Šæ¡†éœ“è™¹å…‰æšˆ */
            box-shadow: 0 0 6px rgba(0, 255, 255, 0.4), inset 0 0 4px rgba(0, 255, 255, 0.3);
            padding: 1px 1px; 
            flex-grow: 1;
            flex-basis: 0;
            height: 95%; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--accent-color);
            text-shadow: 1px 1px 0 #000;
            position: relative;
            transform: skewX(-5deg);
            margin: 0 1px; 
            min-width: 0;
        }

        .hud-panel > * {
            transform: skewX(5deg);
            /* å°‡å…§å®¹åå‘å‚¾æ–œï¼Œä¿æŒå‚ç›´ */
        }

        /* æ¨™ç±¤å­—é«”ï¼šä½¿ç”¨ clamp ç¢ºä¿æœ€å°å°ºå¯¸ */
        .hud-label {
            font-size: clamp(6px, 1vw, 10px); 
            color: #aaa;
            margin-bottom: 1px; 
            text-transform: uppercase;
            text-align: center;
            line-height: 1;
        }

        /* æ•¸å€¼å­—é«”ï¼šä½¿ç”¨ clamp ç¢ºä¿æœ€å°å°ºå¯¸ */
        .hud-value {
            font-size: clamp(8px, 2.5vw, 16px); 
            font-weight: bold;
            white-space: nowrap;
        }

        /* ç›®æ¨™é¢æ¿ç‰¹åˆ¥æ¨£å¼ */
        #target-panel {
            flex-basis: 35%; 
            background: var(--bg-color);
            border: 3px solid var(--text-highlight);
            box-shadow: 0 0 12px var(--text-highlight), inset 0 0 8px var(--text-highlight); 
            color: var(--text-highlight);
        }
        
        #target-val {
            font-family: var(--font-title);
            font-weight: 900;
            font-size: clamp(10px, 3.5vw, 22px); 
            line-height: 1.1; 
            word-break: break-word;
        }

        /* ç§»é™¤ HP ç›¸é—œæ¨£å¼ï¼Œæ”¹ç”¨ DANGER æç¤º */
        #fail-indicator {
            color: var(--danger-color);
            border-color: var(--danger-color);
        }

        /* ---------------------------------------------------- */
        /* è¼”åŠ©è¢å¹•æ¨£å¼ (çµ•å°å®šä½ï¼Œè¦†è“‹åœ¨æ•´å€‹ #game-container ä¸Šæ–¹) */
        /* ---------------------------------------------------- */
        .overlay-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(11, 15, 20, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            color: var(--accent-color);
            padding: 20px;
            box-sizing: border-box;
            transition: opacity 0.3s;
        }

        .hidden { 
            opacity: 0;
            pointer-events: none;
            display: none; 
        }

        .doom-title {
            font-size: clamp(24px, 7vw, 50px);
            color: var(--text-highlight);
            text-shadow: 0 0 10px var(--accent-color), 0 0 20px rgba(255, 0, 255, 0.5);
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.5;
            font-family: var(--font-title);
            font-weight: 900;
            border-bottom: 3px dashed var(--accent-color);
            padding-bottom: 10px;
        }

        .btn {
            background: var(--accent-color);
            color: #000;
            border: 2px solid #fff;
            padding: 18px 35px;
            font-family: var(--font-main);
            font-size: clamp(10px, 2vw, 14px);
            cursor: pointer;
            margin-top: 15px;
            box-shadow: 0 0 10px var(--accent-color), 0 0 20px var(--accent-color) inset;
            border-radius: 4px;
            transition: transform 0.1s, box-shadow 0.1s, background 0.1s;
            text-align: center;
            line-height: 1.3;
        }
        
        .btn:hover {
            background: #fff;
            color: var(--accent-color);
        }

        .btn:active { 
            transform: translateY(2px);
            box-shadow: 0 0 5px var(--accent-color);
        }

        .level-btns-container, .mode-btns-container, .difficulty-btns-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 90%;
            max-width: 450px;
        }
        
        /* å‚·å®³ç‰¹æ•ˆ */
        #damage-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--danger-color);
            opacity: 0;
            pointer-events: none;
            z-index: 15;
            mix-blend-mode: overlay;
            transition: opacity 0.1s;
        }

        /* æµ®å‹•æ–‡å­— */
        .msg {
            position: absolute;
            font-family: var(--font-title);
            font-weight: 900;
            pointer-events: none;
            animation: popOut 0.8s forwards;
            z-index: 30; 
            white-space: nowrap;
        }
        
        @keyframes popOut {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -100%) scale(1); opacity: 0; }
        }

    </style>
</head>
<body>

    <div id="game-container">
        
        <div id="doom-hud">
            <div class="hud-panel">
                <div class="hud-label">STAGE</div>
                <div class="hud-value" id="stage-val">1</div>
            </div>
            
            <div class="hud-panel" style="color:var(--text-highlight);">
                <div class="hud-label">SCORE</div>
                <div class="hud-value" id="score-val">0</div>
            </div>
     
           
            <div class="hud-panel" id="target-panel">
                <div class="hud-label" id="target-title">TARGET PROTOCOL</div>
                <div class="hud-value" id="target-val">--</div>
            </div>
            
            <div class="hud-panel">
     
                <div class="hud-label">PARRY COUNT</div>
                <div class="hud-value" id="parry-val">0/3</div>
            </div>
            
            <div class="hud-panel" id="timer-panel" style="border-color: var(--hud-border); color: var(--hud-border);">
                <div class="hud-label">TIME</div>
                <div class="hud-value" id="timer-val">0.0</div>
            </div>

            <div class="hud-panel" id="fail-indicator">
                <div class="hud-label">STATUS</div>
                <div class="hud-value" id="status-val" style="color:var(--danger-color);">ACTIVE</div>
            </div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        
        <div id="damage-overlay"></div>
        
        <div id="start-screen" class="overlay-screen">
            <div class="doom-title">MATH SLASH<br><span style="font-size:0.6em; color:#fff;">æ•¸å­¸ä¹‹åˆƒ V2.4</span></div>
            <p style="color:#aaa; font-size:clamp(10px, 1.5vw, 14px); margin-bottom: 20px; text-align: center;">
                COMBINE NODES TO HIT THE TARGET VALUE.
            </p>
            <button id="start-btn" class="btn" onclick="showModeSelect()" disabled>LOADING...</button>
        </div>
        
        <div id="mode-select-screen" class="overlay-screen hidden">
            <div class="doom-title">SELECT INTERFACE MODE</div>
       
            <p style="color:#fff; font-size:clamp(10px, 1.5vw, 14px); margin-bottom: 20px; text-align: center;">
                è«‹é¸æ“‡æ‚¨çš„è¼¸å…¥æ¨¡å¼ï¼š
            </p>
            <div class="mode-btns-container">
                <button class="btn" onclick="setInteractionMode('CLICK')">
                    [PC] CLICK MODE (é»æ“Š)<br><span style="font-size:0.7em; color:#ffff50;">(æ»‘é¼ é»æ“Šæ•¸å­—ç¯€é»é€²è¡Œé¸ä¸­/é…å°)</span>
                </button>
                <button class="btn" onclick="setInteractionMode('SLASH')">
                    [MOBILE] SLASH MODE (æ–¬æ“Š)<br><span style="font-size:0.7em; color:#ffff50;">(æ»‘å‹•æ‰‹æŒ‡/æ»‘é¼ æ‹–æ›³é€²è¡Œé€£ç·šæ–¬æ“Š)</span>
                </button>
            </div>
        </div>

        <div id="level-select-screen" class="overlay-screen hidden">
            <div class="doom-title">SELECT MISSION TYPE</div>
            <div class="level-btns-container">
                <button class="btn" onclick="selectLevelType('SUM', 'EASY')">
                    [TYPE 1] SUM PROTOCOL (åŠ æ³•æ‹†åˆ†)<br><span style="font-size:0.7em; color:#00ffff;">(æ‰¾å‡ºå…©æ•¸ç›¸åŠ ç­‰æ–¼ç›®æ¨™)</span>
                </button>
                <button id="factor-btn" class="btn" onclick="showDifficultySelect('FACTOR')">
                    [TYPE 2] FACTOR PROTOCOL (å› æ•¸åˆ†è§£)<br><span style="font-size:0.7em; color:#00ffff;">(é¸æ“‡é›£åº¦)</span>
                </button>
                </div>
        </div>

        <div id="difficulty-select-screen" class="overlay-screen hidden">
            <div class="doom-title">FACTOR PROTOCOL: DIFFICULTY</div>
            <p style="color:#fff; font-size:clamp(10px, 1.5vw, 14px); margin-bottom: 20px; text-align: center;">
                è«‹é¸æ“‡å› æ•¸åˆ†è§£é›£åº¦ï¼š
            </p>
            <div class="difficulty-btns-container">
                <button class="btn" onclick="selectLevelType('FACTOR', 'NOVICE')">
                    NOVICE MODE (æ–°æ‰‹)<br><span style="font-size:0.7em; color:#00ffff;">(åˆæ•¸ $1\sim100$ï¼Œå› å­ $1\sim50$)</span>
                </button>
                <button class="btn" onclick="selectLevelType('FACTOR', 'EASY')">
                    EASY MODE (åˆéš)<br><span style="font-size:0.7em; color:#00ffff;">(åˆæ•¸ $1\sim400$ï¼Œå› å­ $1\sim20$)</span>
                </button>
                <button class="btn" onclick="selectLevelType('FACTOR', 'MID')">
                    MIDDLE MODE (ä¸­éš)<br><span style="font-size:0.7em; color:#fffa50;">(åˆæ•¸ $200\sim1000$ï¼Œå› å­ $10\sim50$)</span>
                </button>
                <button class="btn" onclick="selectLevelType('FACTOR', 'HIGH')">
                    HIGH MODE (é«˜éš)<br><span style="font-size:0.7em; color:orange;">(åˆæ•¸ $500\sim3000$ï¼Œå› å­ $20\sim80$)</span>
                </button>
                <button class="btn" onclick="selectLevelType('FACTOR', 'CHALLENGE')">
                    CHALLENGE MODE (æŒ‘æˆ°)<br><span style="font-size:0.7em; color:var(--danger-color);">(åˆæ•¸ $2000\sim10000$ï¼Œå› å­ $50\sim100$)</span>
                </button>
            </div>
        </div>

        <div id="ready-screen" class="overlay-screen hidden" style="background: rgba(0,0,0,0.6);">
            <div class="doom-title" style="color:var(--hud-border);">TARGET LOCKED</div>
            <div style="color:#fff; font-size:clamp(12px, 2vw, 18px); margin-bottom:20px;">INITIATE SEQUENCE?</div>
            <button class="btn" onclick="startRound()">START SLASHING</button>
        </div>

        <div id="clear-screen" class="overlay-screen hidden">
            <div class="doom-title" style="color:var(--hud-border);">PROTOCOL CLEARED</div>
            <p style="color:#fff; font-size:clamp(12px, 2vw, 16px);">TIME BONUS: <span id="clear-time" style="color:var(--hud-border);">0.00</span>s</p>
            <button class="btn" onclick="nextStage()">NEXT SECTOR</button>
        </div>

        <div id="gameover-screen" class="overlay-screen hidden">
            <div class="doom-title" style="color:var(--danger-color);">MISSION FAILED</div>
            <p style="color:#fff; font-size:clamp(12px, 2vw, 16px);">FINAL SCORE: <span id="final-score">0</span></p>
            <p style="color:var(--danger-color); font-size:clamp(10px, 1.5vw, 14px); margin-top:10px;">å› éŒ¯èª¤æ“ä½œå°è‡´ç³»çµ±æ ¸å¿ƒçµ‚æ­¢ã€‚</p>
            <button class="btn" onclick="showModeSelect()">RETRY</button>
        </div>

    </div>

    <script>
        /**
         * Math Slash Cyberpunk V2.4 - MODIFIED
         * * ä¿®æ­£é …ç›®ï¼š
         * 1. ç§»é™¤ SEQUENCE PROTOCOLã€‚
         * 2. ç§»é™¤ HP ç³»çµ±ï¼Œç­”éŒ¯å³å¤±æ•— (GameOver)ã€‚
         * 3. FACTOR PROTOCOL æ“´å¢è‡³ 5 å€‹é›£åº¦ï¼Œä¸¦ä¾éœ€æ±‚èª¿æ•´ç¯„åœã€‚
         * 4. å¼·åŒ– FACTOR èª˜ç­”æ€§ (å€‹ä½æ•¸èª¤å° + æ•¸å€¼æ¥µåº¦é„°è¿‘)ã€‚
         */

        // --- Configuration & Constants ---
        const CONFIG = {
            BASE_WIDTH: 800,
            BASE_HEIGHT: 600,
            CANDIDATE_BASE_SIZE: 50,
            PARRY_NEEDED: 3,
            FINAL_STAGE: 6, 
            SWIPE_TIMEOUT_MS: 2000,
            TRAIL_LENGTH: 15,
            COLORS: {
                bg: '#0b0f14',
                trail: '#ff00ff', // Slash color (Magenta)
                trailShadow: '#00ffff',
                text: '#ffffff',
                highlight: '#fffa50',
                // æ•¸å­—çƒçš„é¡è‰²è¨­å®š
                part1: '#ff00ff', // First selected part color (Magenta)
                part2: '#00ffff', // Second selected part color (Cyan)
                decoys: '#444', 
                decoysStroke: '#00ffff'
            },
            INTERACTION_MODE: null
        };
        // --- Global State ---
        const state = {
            screen: 'START',
            levelType: 'SUM',
            difficulty: 'EASY', 
            stage: 1,
            score: 0,
            parryCount: 0,
            startTime: 0,
            targetValue: 0,
            candidates: [],
            particles: [],
            solutionPair: [], 
            partialSelection: null, 
            partialTimer: 0,
            scaleFactor: 1,
            pointer: { x: 0, y: 0, isDown: false, trail: [] },
        };
        // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        const hud = document.getElementById('doom-hud');
        const ui = {
            stage: document.getElementById('stage-val'),
            score: document.getElementById('score-val'),
            targetVal: document.getElementById('target-val'),
            targetTitle: document.getElementById('target-title'),
            parry: document.getElementById('parry-val'),
            timer: document.getElementById('timer-val'),
            status: document.getElementById('status-val'), // æ–°çš„ç‹€æ…‹æŒ‡ç¤ºå™¨
            screens: {
                start: document.getElementById('start-screen'),
                mode: document.getElementById('mode-select-screen'),
                level: document.getElementById('level-select-screen'),
                difficulty: document.getElementById('difficulty-select-screen'),
                ready: document.getElementById('ready-screen'),
                clear: document.getElementById('clear-screen'),
                gameover: document.getElementById('gameover-screen')
            }
        };
        // --- Background Asset ---
        const bgImage = new Image();
        bgImage.src = 'https://placehold.co/1024x768/000/00ffff?text=CYBERNETIC+GRID';
        bgImage.onload = () => {
            document.getElementById('start-btn').disabled = false;
            document.getElementById('start-btn').innerText = "START MISSION";
        };

        // --- Resizing & Responsive Logic ---
        function resize() {
            const w = gameContainer.clientWidth;
            const h = gameContainer.clientHeight;
            const hudHeight = hud.offsetHeight;
            
            // DPI Scaling (Retina support)
            const dpr = window.devicePixelRatio || 1;
            
            // Canvas width/height: full container width, height minus HUD height
            canvas.width = w * dpr;
            canvas.height = (h - hudHeight) * dpr;
            
            // Normalize coordinate system
            ctx.scale(dpr, dpr);
            canvas.style.width = `${w}px`;
            canvas.style.height = `${h - hudHeight}px`;

            // Calculate Scale Factor based on reference resolution
            state.scaleFactor = Math.min(w / CONFIG.BASE_WIDTH, (h - hudHeight) / CONFIG.BASE_HEIGHT) * 1.2;
            if (w < 600) state.scaleFactor *= 1.2;
        }
        window.addEventListener('resize', resize);
        resize();
        
        // --- Input Handling ---

        function getCanvasPos(evt) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function triggerHitCheck(x, y) {
            if (state.screen !== 'PLAYING') return;
            const hitCandidate = getHitCandidate({ x, y });
            if (hitCandidate) {
                processHit(hitCandidate);
            }
        }
        
        function handlePointerDown(e) {
            if (state.screen !== 'PLAYING') return;
            if (e.type === 'mousedown') e.preventDefault(); 
            
            const pos = getCanvasPos(e);
            state.pointer.x = pos.x;
            state.pointer.y = pos.y;
            state.pointer.isDown = true;
            state.pointer.trail = [{x: pos.x, y: pos.y}];
            
            if (CONFIG.INTERACTION_MODE === 'CLICK') {
                triggerHitCheck(pos.x, pos.y);
            }
        }

        function handlePointerMove(e) {
            if (!state.pointer.isDown || state.screen !== 'PLAYING') return;
            e.preventDefault(); 
            
            const pos = getCanvasPos(e);
            
            state.pointer.trail.push({x: pos.x, y: pos.y});
            if (state.pointer.trail.length > CONFIG.TRAIL_LENGTH) {
                state.pointer.trail.shift();
            }

            if (CONFIG.INTERACTION_MODE === 'SLASH') {
                checkLineCollision(state.pointer.x, state.pointer.y, pos.x, pos.y);
            }

            state.pointer.x = pos.x;
            state.pointer.y = pos.y;
        }

        function handlePointerUp(e) {
            state.pointer.isDown = false;
            state.pointer.trail = [];
        }

        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mousemove', handlePointerMove);
        window.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('touchstart', handlePointerDown, {passive: false});
        canvas.addEventListener('touchmove', handlePointerMove, {passive: false});
        window.addEventListener('touchend', handlePointerUp);
        // --- Game Logic Classes (Unchanged) ---
        
        class Candidate {
            constructor(val, solutionKey, type='number') {
                this.text = String(val);
                this.solutionKey = solutionKey; // 'P1', 'P2', 'DECOY'
                this.dataType = type; 
                
                this.radius = (CONFIG.CANDIDATE_BASE_SIZE / 2) * state.scaleFactor;
                const w = canvas.width / (window.devicePixelRatio || 1);
                const h = canvas.height / (window.devicePixelRatio || 1);
                const margin = this.radius * 2;
                
                // Position finding logic...
                let attempts = 0;
                let safe = false;
                while(!safe && attempts < 50) {
                    this.x = margin + Math.random() * (w - margin * 2);
                    this.y = margin + Math.random() * (h - margin * 2);
                    
                    safe = true;
                    for (let c of state.candidates) {
                        const dist = Math.hypot(this.x - c.x, this.y - c.y);
                        if (dist < (this.radius + c.radius) * 1.5) { 
                            safe = false;
                            break;
                        }
                    }
                    attempts++;
                }

                // Random velocity (scaled)
                const speed = (0.5 + Math.random() * 1.0) * state.scaleFactor;
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.highlighted = false;
                this.selected = false;
                this.scaleAnim = 1;
            }

            update() {
                const w = canvas.width / (window.devicePixelRatio || 1);
                const h = canvas.height / (window.devicePixelRatio || 1);

                this.x += this.vx;
                this.y += this.vy;
                // Boundary bounce
                if (this.x < this.radius) { this.x = this.radius; this.vx *= -1; }
                if (this.x > w - this.radius) { this.x = w - this.radius; this.vx *= -1; }
                if (this.y < this.radius) { this.y = this.radius; this.vy *= -1; }
                if (this.y > h - this.radius) { this.y = h - this.radius; this.vy *= -1; }

                if (this.selected) {
                    this.scaleAnim = 1 + Math.sin(Date.now() / 100) * 0.1;
                } else {
                    this.scaleAnim = 1;
                }
            }

            draw() {
                const r = this.radius * this.scaleAnim;
                ctx.save();
                ctx.translate(this.x, this.y);

                // Cyberpunk Glow Effect
                ctx.shadowBlur = this.highlighted || this.selected ? 30 : 10;
                const glowColor = this.selected ? (this.solutionKey === 'P1' ? CONFIG.COLORS.part1 : CONFIG.COLORS.part2) : CONFIG.COLORS.decoysStroke;
                ctx.shadowColor = glowColor;

                // Fill
                ctx.fillStyle = this.selected ? 'rgba(0,0,0,0.8)' : CONFIG.COLORS.decoys;
                
                // Border Color based on selection part
                let strokeColor = CONFIG.COLORS.decoysStroke;
                if (this.selected) {
                    strokeColor = this.solutionKey === 'P1' ? CONFIG.COLORS.part1 : CONFIG.COLORS.part2;
                } else if (this.highlighted) {
                    strokeColor = CONFIG.COLORS.highlight;
                }

                ctx.lineWidth = 4 * state.scaleFactor;
                ctx.strokeStyle = strokeColor;

                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                // Text
                ctx.shadowBlur = 0;
                ctx.fillStyle = this.selected ? '#fff' : strokeColor; 
                ctx.font = `${Math.floor(20 * state.scaleFactor)}px "Press Start 2P"`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, 0, 2 * state.scaleFactor);

                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 * state.scaleFactor;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = 0.03;
                this.size = (Math.random() * 4 + 2) * state.scaleFactor;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // --- Screen Management ---

        function switchScreen(screenName) {
            state.screen = screenName;
            Object.values(ui.screens).forEach(el => el.classList.add('hidden'));
            
            if (screenName === 'START') ui.screens.start.classList.remove('hidden');
            if (screenName === 'MODE_SELECT') ui.screens.mode.classList.remove('hidden');
            if (screenName === 'LEVEL_SELECT') ui.screens.level.classList.remove('hidden');
            if (screenName === 'DIFFICULTY_SELECT') ui.screens.difficulty.classList.remove('hidden');
            if (screenName === 'READY') ui.screens.ready.classList.remove('hidden');
            if (screenName === 'CLEARED') ui.screens.clear.classList.remove('hidden');
            if (screenName === 'GAMEOVER') ui.screens.gameover.classList.remove('hidden');
        }

        function showModeSelect() {
            // Reset game state on full restart
            state.stage = 1;
            state.score = 0;
            ui.stage.innerText = `1 (E)`;
            ui.parry.innerText = `0/${CONFIG.PARRY_NEEDED}`;
            ui.score.innerText = '0';
            ui.timer.innerText = '0.0';
            ui.status.innerText = 'ACTIVE';
            switchScreen('MODE_SELECT');
        }
        
        function setInteractionMode(mode) {
            CONFIG.INTERACTION_MODE = mode;
            switchScreen('LEVEL_SELECT');
        }

        function selectLevelType(type, difficulty) {
            state.levelType = type;
            state.difficulty = difficulty;
            setupStage();
        }

        function showDifficultySelect(type) {
            state.levelType = type;
            switchScreen('DIFFICULTY_SELECT');
        }

        function setupStage() {
            state.candidates = [];
            state.partialSelection = null;
            state.parryCount = 0;
            
            // ç°¡åŒ–é›£åº¦ä»£ç¢¼é¡¯ç¤º
            let diffCode = state.difficulty.substring(0, 1);
            if (state.difficulty === 'NOVICE') diffCode = 'N';
            if (state.difficulty === 'MID') diffCode = 'M';
            if (state.difficulty === 'HIGH') diffCode = 'H';
            if (state.difficulty === 'CHALLENGE') diffCode = 'C';

            ui.stage.innerText = `${state.stage} (${diffCode})`;
            ui.parry.innerText = `0/${CONFIG.PARRY_NEEDED}`;
            ui.timer.innerText = "0.0";

            // Generate Data
            const data = generateLevelData(state.levelType, state.stage, state.difficulty);
            state.targetValue = data.target;
            state.solutionPair = data.pair;

            // Setup UI Display
            ui.targetTitle.innerText = state.levelType + ' (' + state.difficulty + ')';
            ui.targetVal.innerText = state.targetValue;

            // Spawn Candidates
            state.candidates.push(new Candidate(data.pair[0], 'P1', data.type));
            state.candidates.push(new Candidate(data.pair[1], 'P2', data.type));
            
            // Decoys
            data.decoys.forEach(decoy => {
                state.candidates.push(new Candidate(decoy, 'DECOY', data.type));
            });

            switchScreen('READY');
        }

        function startRound() {
            switchScreen('PLAYING');
            if (state.stage === 1) {
                state.startTime = performance.now();
            }
        }

        function handleClear() { 
            state.score += 500; 
            ui.score.innerText = state.score;

            if (state.stage >= CONFIG.FINAL_STAGE) {
                const time = (performance.now() - state.startTime) / 1000;
                document.getElementById('clear-time').innerText = time.toFixed(2) + "s";
                document.getElementById('clear-screen').querySelector('.doom-title').innerText = "MISSION COMPLETE";
                document.getElementById('clear-screen').querySelector('.btn').innerText = "RESTART (TO MENU)";
                document.getElementById('clear-screen').querySelector('.btn').onclick = showModeSelect; 
            } else {
                document.getElementById('clear-time').innerText = "STAGE " + state.stage + " CLEARED";
                document.getElementById('clear-screen').querySelector('.doom-title').innerText = "PROTOCOL CLEARED";
                document.getElementById('clear-screen').querySelector('.btn').innerText = "NEXT SECTOR";
                document.getElementById('clear-screen').querySelector('.btn').onclick = nextStage; 
            }

            switchScreen('CLEARED'); 
        }

        function nextStage() { 
            state.stage++; 
            setupStage(); 
        }

        // --- Collision & Interaction ---
        function getHitCandidate({x, y}) {
            for (let c of state.candidates) {
                const dx = x - c.x;
                const dy = y - c.y;
                if (dx*dx + dy*dy < c.radius * c.radius) {
                    return c;
                }
            }
            return null;
        }

        function checkLineCollision(x1, y1, x2, y2) {
            for (let c of state.candidates) {
                if (c.selected && c === state.partialSelection) continue;
                const dist = pointToSegmentDistance(c.x, c.y, x1, y1, x2, y2);
                if (dist < c.radius) {
                    processHit(c);
                    return;
                }
            }
        }

        // Standard point-line distance function
        function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
            const l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            if (l2 == 0) return Math.hypot(px - x1, py - y1);
            let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
            t = Math.max(0, Math.min(1, t));
            const nx = x1 + t * (x2 - x1);
            const ny = y1 + t * (y2 - y1);
            return Math.hypot(px - nx, py - ny);
        }

        function processHit(candidate) {
            
            if (candidate.solutionKey === 'DECOY') {
                // åªè¦æ‰“ä¸­èª˜ç­”æ•¸å­—ï¼Œç«‹åˆ»å¤±æ•—
                handleFail("ERROR: DECOY HIT! MISSION FAILED.", 10);
                return;
            }

            if (state.partialSelection === candidate) {
                // Deselecting the first part
                state.partialSelection.selected = false;
                state.partialSelection = null;
                showFloatMsg(candidate.x, candidate.y, "CANCELLED", false);
                return;
            }

            if (state.partialSelection === null) {
                // First Hit
                state.partialSelection = candidate;
                candidate.selected = true;
                state.partialTimer = Date.now();
                showFloatMsg(candidate.x, candidate.y, "NODE LOCKED", true);
            } else {
                // Second Hit - Check if it's the remaining part
                const otherKey = state.partialSelection.solutionKey === 'P1' ? 'P2' : 'P1';

                if (candidate.solutionKey === otherKey) {
                    // Success!
                    scoreSuccess(candidate.x, candidate.y);
                } else {
                    // Two correct nodes but already selected, should not happen in Factor/Sum
                    handleFail("PROTOCOL MISMATCH! MISSION FAILED.", 10);
                }
            }
        }

        function scoreSuccess(x, y) {
            state.score += 100; 
            ui.score.innerText = state.score;
            spawnParticles(x, y, CONFIG.COLORS.highlight);

            state.partialSelection = null;
            state.parryCount++;
            ui.parry.innerText = `${state.parryCount}/${CONFIG.PARRY_NEEDED}`;
            
            // Clear the round or respawn
            if (state.parryCount >= CONFIG.PARRY_NEEDED) {
                handleClear();
            } else {
                respawnCandidates();
            }
        }

        function handleFail(msg, damage) {
            ui.status.innerText = 'FAILED';
            showFloatMsg(canvas.width / 2 / (window.devicePixelRatio || 1), canvas.height / 2 / (window.devicePixelRatio || 1), msg, false);
            document.getElementById('damage-overlay').style.opacity = 0.8;
            setTimeout(() => { document.getElementById('damage-overlay').style.opacity = 0; }, 200);

            // ç­”éŒ¯å³åˆ»çµæŸéŠæˆ²
            handleGameOver();
        }

        function handleGameOver() {
            document.getElementById('final-score').innerText = state.score;
            switchScreen('GAMEOVER');
        }

        function respawnCandidates() {
            // Respawn logic remains the same, but it generates data using the selected difficulty
            const data = generateLevelData(state.levelType, state.stage, state.difficulty);
            state.targetValue = data.target;
            state.solutionPair = data.pair;
            ui.targetVal.innerText = state.targetValue;
            state.candidates = [];
            state.candidates.push(new Candidate(data.pair[0], 'P1', data.type));
            state.candidates.push(new Candidate(data.pair[1], 'P2', data.type));
            data.decoys.forEach(decoy => {
                state.candidates.push(new Candidate(decoy, 'DECOY', data.type));
            });
        }

        function showFloatMsg(x, y, text, good) {
            const el = document.createElement('div');
            el.className = 'msg';
            el.innerText = text;
            const canvasRect = canvas.getBoundingClientRect();
            el.style.left = (x + canvasRect.left) + 'px';
            el.style.top = (y + canvasRect.top) + 'px';
            el.style.color = good ? 'var(--hud-border)' : 'var(--danger-color)';
            el.style.textShadow = good ? '0 0 5px var(--hud-border)' : '0 0 5px var(--danger-color)';
            el.style.fontSize = (20 * state.scaleFactor) + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function spawnParticles(x, y, color) {
            for(let i=0; i<10; i++) {
                state.particles.push(new Particle(x, y, color));
            }
        }
        
        // --- Data Generation (æ ¸å¿ƒä¿®æ”¹) ---
        function generateLevelData(type, stage, difficulty) {
            const baseCount = Math.min(8 + Math.floor(stage / 2), 12);
            
            if (type === 'SUM') {
                // SUM PROTOCOL (åŠ æ³•æ‹†åˆ†) é‚è¼¯ä¿æŒä¸è®Š
                const minTarget = difficulty === 'HARD' ? 100 : 20;
                const maxTarget = difficulty === 'HARD' ? 500 : 100;
                const target = Math.floor(Math.random() * (maxTarget - minTarget + 1)) + minTarget;
                
                const p1 = Math.floor(Math.random() * (target - 1)) + 1;
                const p2 = target - p1;

                const max_val = target - 1; 
                const proximity_range = Math.max(3, Math.floor(Math.sqrt(target) / 3)); 
                const required_decoys_count = baseCount - 2;
                
                const solutions = [p1, p2];
                const decoysSet = new Set();
                
                while (decoysSet.size < required_decoys_count) {
                    let decoy = -1;
                    const rng = Math.random();

                    // 90% æ©Ÿç‡é¸æ“‡æ¥è¿‘å…¶ä¸­ä¸€å€‹ç­”æ¡ˆçš„æ•¸å­—
                    const targetPart = solutions[rng < 0.45 ? 0 : (rng < 0.90 ? 1 : -1)];
                    
                    if (targetPart !== -1) { 
                        const min_d = Math.max(1, targetPart - proximity_range);
                        const max_d = Math.min(max_val, targetPart + proximity_range);
                        
                        if (min_d >= max_d) { decoy = min_d; } 
                        else { decoy = Math.floor(Math.random() * (max_d - min_d + 1)) + min_d; }
                    } else { 
                        const min_d = 1;
                        const max_d = max_val;
                        decoy = Math.floor(Math.random() * (max_d - min_d + 1)) + min_d;
                    }

                    if (decoy !== p1 && decoy !== p2 && decoy >= 1 && decoy <= max_val && !decoysSet.has(decoy)) {
                        decoysSet.add(decoy);
                    }
                }

                return { target: String(target), pair: [p1, p2], decoys: Array.from(decoysSet), type: 'number' };

            } else if (type === 'FACTOR') {
                // FACTOR PROTOCOL (å› æ•¸åˆ†è§£)
                
                // 1. æ ¹æ“šé›£åº¦è¨­å®šç›®æ¨™å€¼(Target)å’Œå› å­(Factor)ç¯„åœ
                const difficultySettings = {
                    'NOVICE': { minTarget: 1, maxTarget: 100, minFactor: 1, maxFactor: 50 },
                    'EASY': { minTarget: 1, maxTarget: 400, minFactor: 1, maxFactor: 20 },
                    'MID': { minTarget: 200, maxTarget: 1000, minFactor: 10, maxFactor: 50 },
                    'HIGH': { minTarget: 500, maxTarget: 3000, minFactor: 20, maxFactor: 80 },
                    'CHALLENGE': { minTarget: 2000, maxTarget: 10000, minFactor: 50, maxFactor: 100 }
                };
                
                const settings = difficultySettings[difficulty];
                let target = 0;
                let p1 = 0;
                let p2 = 0;
                let attempts = 0;

                // 2. ç”¢ç”Ÿç›®æ¨™å€¼å’Œå› æ•¸å° (p1 * p2 = target)
                while ((p1 <= 1 || p1 === target || p1 === p2 || p2 > settings.maxTarget) && attempts < 200) {
                    // éš¨æ©Ÿé¸æ“‡å…©å€‹ç¬¦åˆå› æ•¸ç¯„åœçš„æ•¸å­— (f1, f2)
                    let f1 = Math.floor(Math.random() * (settings.maxFactor - settings.minFactor + 1)) + settings.minFactor;
                    let f2 = Math.floor(Math.random() * (settings.maxFactor - settings.minFactor + 1)) + settings.minFactor;
                    
                    target = f1 * f2;
                    
                    // ç¢ºä¿ target åœ¨ç›®æ¨™ç¯„åœå…§
                    if (target >= settings.minTarget && target <= settings.maxTarget) {
                        p1 = Math.min(f1, f2);
                        p2 = Math.max(f1, f2);
                    } else {
                        target = 0; // ä¸åˆæ ¼ï¼Œç¹¼çºŒå¾ªç’°
                    }
                    attempts++;
                }
                
                if (p1 <= 1 || p1 === p2 || attempts >= 200) {
                     // å¤±æ•—ï¼Œéè¿´é‡è©¦ (é€™åœ¨å¤§éƒ¨åˆ†æƒ…æ³ä¸‹æ‡‰é¿å…ï¼Œä½†ä½œç‚ºç¢ºä¿å› æ•¸å°çš„æœ€çµ‚æ‰‹æ®µ)
                     return generateLevelData(type, stage, difficulty); 
                }

                const p_min = p1;
                const p_max = p2;

                // 3. ç¢ºå®šæ‰€æœ‰å€™é¸äººçš„æœ€å¤§å€¼é™åˆ¶ (é€šå¸¸æ˜¯ p_max + ç¯„åœ æˆ– target / 2)
                const max_val = Math.max(p_max + 10, Math.floor(target * 0.7)); 
                
                // 4. èª˜ç­”é‚è¼¯é…ç½®
                
                // èª˜ç­”ç¯„åœï¼šæ¥µåº¦é è¿‘ç­”æ¡ˆ (é›£åº¦è¶Šé«˜ï¼Œç¯„åœè¶Šå°)
                let proximity_range = 0;
                if (difficulty === 'NOVICE') proximity_range = 10;
                else if (difficulty === 'EASY') proximity_range = 5;
                else if (difficulty === 'MID') proximity_range = 3;
                else if (difficulty === 'HIGH') proximity_range = 2;
                else if (difficulty === 'CHALLENGE') proximity_range = 1; // æŒ‘æˆ°ç‰ˆï¼šèª˜ç­”åªå·® Â±1
                
                // å€‹ä½æ•¸èª¤å°æ©Ÿç‡ï¼šæŒ‘æˆ°ç‰ˆç‚º 95%ï¼Œå…¶ä»–ç‚º 70%
                const LURE_PROBABILITY = (difficulty === 'CHALLENGE') ? 0.95 : (difficulty === 'NOVICE' ? 0.3 : 0.7);

                const required_decoys_count = baseCount - 2;
                let decoys = [];

                // è¼”åŠ©å‡½å¼ï¼šå–å¾—æ‰€æœ‰ã€Œåˆç†çš„ã€å€‹ä½æ•¸ (u1 * u2 % 10 == targetUnitDigit)
                function getPlausibleUnitDigits(targetUnitDigit) {
                    const plausible = [];
                    for (let u1 = 0; u1 <= 9; u1++) {
                        for (let u2 = 0; u2 <= 9; u2++) {
                            if ((u1 * u2) % 10 === targetUnitDigit) {
                                plausible.push(u1);
                                break; 
                            }
                        }
                    }
                    return [...new Set(plausible)].sort((a, b) => a - b);
                }
                
                let plausible_unit_digits = getPlausibleUnitDigits(target % 10);
                
                // 5. ç”Ÿæˆèª˜ç­”æ•¸å­—
                while (decoys.length < required_decoys_count) {
                    let decoy = -1;
                    let rng = Math.random();
                    let targetDecoyVal = 0; 
                    let isProximityLure = (rng < 0.95); // 95% æ©Ÿç‡æ˜¯é„°è¿‘èª˜ç­”

                    if (isProximityLure) {
                        // é¸æ“‡é è¿‘ p_min æˆ– p_max
                        targetDecoyVal = Math.random() < 0.5 ? p_min : p_max;
                        
                        // é„°è¿‘ç”Ÿæˆ
                        let min_d = Math.max(2, targetDecoyVal - proximity_range);
                        let max_d = Math.min(max_val, targetDecoyVal + proximity_range);
                        
                        // ç¢ºä¿ min < maxï¼Œå¦å‰‡å¼·åˆ¶å–é‚Šç•Œå€¼
                        if (min_d >= max_d) { decoy = min_d; } 
                        else { decoy = Math.floor(Math.random() * (max_d - min_d + 1)) + min_d; }
                    } else {
                        // 5% éš¨æ©Ÿç”Ÿæˆï¼Œç¢ºä¿åœ¨åˆç†ç¯„åœå…§
                        decoy = Math.floor(Math.random() * (max_val - 2 + 1)) + 2;
                    }
                    
                    // **å¼·åˆ¶å€‹ä½æ•¸èª˜ç­”é‚è¼¯ (é©ç”¨æ–¼é NOVICE)**
                    if (difficulty !== 'NOVICE' && Math.random() < LURE_PROBABILITY) { 
                        const currentUnit = decoy % 10;
                        
                        if (!plausible_unit_digits.includes(currentUnit)) {
                            // å¿…é ˆé‡æ–°è¨ˆç®—å€‹ä½æ•¸
                            const randomPlausibleUnit = plausible_unit_digits[Math.floor(Math.random() * plausible_unit_digits.length)];
                            
                            // ä¿æŒå¤§è‡´æ•¸é‡ç´šï¼Œåªæ›¿æ›å€‹ä½æ•¸
                            let newDecoy = Math.floor(decoy / 10) * 10 + randomPlausibleUnit;
                            
                            // å¦‚æœèª¿æ•´å¾Œå°è‡´æ•¸å€¼ç­‰æ–¼ p1 æˆ– p2ï¼Œå‰‡å¾®èª¿åä½æ•¸
                            if (newDecoy === p1 || newDecoy === p2) {
                                if (Math.random() < 0.5) {
                                    newDecoy += 10;
                                } else {
                                    newDecoy -= 10;
                                }
                            }
                            
                            // æœ€çµ‚ç¢ºä¿ newDecoy ä»åœ¨åˆæ³•ç¯„åœ [2, max_val]
                            if (newDecoy >= 2 && newDecoy <= max_val) {
                                decoy = newDecoy;
                            }
                        }
                    }

                    // ç¢ºä¿èª˜ç­”æ•¸å­—æ˜¯ç¨ä¸€ç„¡äºŒï¼Œä¸”ä¸æ˜¯æ­£ç¢ºç­”æ¡ˆ
                    if (decoy !== p1 && decoy !== p2 && decoy >= 2 && decoy <= max_val && !decoys.includes(decoy)) {
                        decoys.push(decoy);
                    }
                }

                return { target: String(target), pair: [p1, p2], decoys: decoys, type: 'number' };

            } else if (type === 'SEQUENCE') {
                 // è©²æ¨¡å¼å·²åˆªé™¤ï¼Œåœ¨æ­¤ä¸åšä»»ä½•è™•ç†ï¼Œè‹¥ç™¼ç”Ÿè¡¨ç¤ºé‚è¼¯éŒ¯èª¤
                 return { target: "ERROR", pair: [1, 1], decoys: [2, 3], type: 'number' };
            }
        }


        // --- Main Loop ---
        function loop() {
            requestAnimationFrame(loop);
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            ctx.fillStyle = CONFIG.COLORS.bg;
            ctx.fillRect(0, 0, w, h);

            // Draw background grid effect
            ctx.globalAlpha = 0.1;
            ctx.drawImage(bgImage, 0, 0, w, h);
            ctx.globalAlpha = 1;

            // Update and draw candidates
            state.candidates.forEach(c => c.update());
            state.candidates.forEach(c => c.draw());

            // Handle partial selection timeout
            if (state.partialSelection !== null) {
                if (Date.now() - state.partialTimer > CONFIG.SWIPE_TIMEOUT_MS) {
                    state.partialSelection.selected = false;
                    state.partialSelection = null;
                    // æ™‚é–“åˆ°ï¼Œè¦–ç‚ºéŒ¯èª¤ï¼Œç«‹å³å¤±æ•—
                    handleFail("DATA LINK EXPIRED! MISSION FAILED.", 10); 
                }
            }

            state.particles = state.particles.filter(p => p.life > 0);
            state.particles.forEach(p => { p.update(); p.draw(); });

            // Draw Trail (Slash Effect)
            if (state.pointer.isDown && state.pointer.trail.length > 1 && CONFIG.INTERACTION_MODE === 'SLASH') {
                ctx.beginPath();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = 6 * state.scaleFactor;
                ctx.strokeStyle = CONFIG.COLORS.trail;
                ctx.shadowBlur = 15;
                ctx.shadowColor = CONFIG.COLORS.trailShadow;
                
                const trail = state.pointer.trail;
                ctx.moveTo(trail[0].x, trail[0].y);
                
                // Quadratic bezier for smooth curve
                for (let i = 1; i < trail.length - 1; i++) {
                    const xc = (trail[i].x + trail[i+1].x) / 2;
                    const yc = (trail[i].y + trail[i+1].y) / 2;
                    ctx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);
                }
                if(trail.length > 2) ctx.lineTo(trail[trail.length-1].x, trail[trail.length-1].y);
                
                ctx.stroke();
                ctx.shadowBlur = 0; 
                ctx.strokeStyle = CONFIG.COLORS.trailShadow;
                ctx.lineWidth = 1 * state.scaleFactor;
                ctx.stroke();
            }

            // Update Timer Display (in real-time)
            if (state.screen === 'PLAYING' && state.startTime !== 0) {
                const timeElapsed = (performance.now() - state.startTime) / 1000;
                ui.timer.innerText = timeElapsed.toFixed(1);
            }
        }

        loop();

    </script>
</body>
</html>
