<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Math Slash - æ•¸å­¸ä¹‹åˆƒ (Cyberpunk ç‰ˆ)</title>
    <style>
        /* å¼•å…¥é»é™£å­—é«”å’Œç¹é«”ä¸­æ–‡é»‘é«” */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Noto+Serif+TC:wght@900&display=swap');
/* Cyberpunk Color Palette */
        :root {
            --bg-color: #0b0f14;
            --hud-bg: #1e2531;
            --hud-border: #00ffff; /* éœ“è™¹é’è‰² */
            --accent-color: #ff00ff;
/* éœ“è™¹æ´‹ç´… */
            --text-highlight: #fffa50;
/* é›»å…‰é»ƒ */
            --hp-color: #00ff88;
/* ç¶ è‰²å¥åº· */
            --danger-color: #ff3333;
            --font-main: 'Press Start 2P', cursive;
            --font-title: 'Noto Serif TC', serif;
        }

        /* ç¢ºä¿å…¨è¢å¹•ä¸”ç„¡æ²è»¸ */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--font-main);
            touch-action: none;
/* ç¦æ­¢æ‰‹æ©Ÿä¸Šçš„é è¨­æ‰‹å‹¢ */
            user-select: none;
            -webkit-user-select: none;
        }

        /* ä½¿ç”¨ Flexbox ç¢ºä¿ HUD åœ¨ä¸Šï¼ŒCanvas åœ¨ä¸‹ */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: var(--bg-color);
            display: flex;
            flex-direction: column; 
/* è®“å…§å®¹å‚ç›´å †ç–Š */
        }

        /* ğŸ¤– HUD ä»‹é¢å„ªåŒ– - ç¢ºä¿ä¸æº¢å‡ºä»‹é¢ (ç¾åœ¨å›ºå®šåœ¨ä¸Šæ–¹) */
        #doom-hud {
            width: 100%;
            height: 10vh; /* èª¿é™é«˜åº¦æ¯”ä¾‹ */
            max-height: 90px; /* ç¡¬æ€§æœ€å¤§é«˜åº¦ */
            background: var(--hud-bg);
            border-bottom: 3px solid var(--hud-border); /* **å°‡é‚Šæ¡†ç§»åˆ°åº•éƒ¨** */
            /* æ©«å‘æƒæç·šæ•ˆæœ */
            background-image: linear-gradient(rgba(0,0,0,0.5) 1px, transparent 1px);
            background-size: 100% 4px; 
            
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            z-index: 10;
            box-shadow: 0 0 15px var(--accent-color);
            padding: 2px 0; 
            box-sizing: border-box;
            flex-shrink: 0; 
/* ä¸å…è¨± HUD è¢«å£“ç¸®ï¼Œä¿æŒå›ºå®šé«˜åº¦ */
        }

        /* ç•«å¸ƒä½”æ“šå‰©é¤˜ç©ºé–“ (åº•éƒ¨å€åŸŸ) */
        canvas {
            display: block;
            flex-grow: 1; /* ä½”æ“šæ‰€æœ‰å¯ç”¨çš„å‚ç›´ç©ºé–“ */
            width: 100%;
            cursor: crosshair;
/* è®“ Canvas å…·æœ‰ç´°å¾®çš„ç™¼å…‰é‚Šæ¡† */
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        /* ---------------------------------------------------- */
        /* ä»¥ä¸‹ HUD å…§éƒ¨æ¨£å¼èˆ‡è¼”åŠ©è¢å¹•æ¨£å¼ä¸è®Šï¼Œä¿æŒç·Šæ¹Šè¨­è¨ˆ */
        /* ---------------------------------------------------- */

        .hud-panel {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--hud-border);
            /* é‚Šæ¡†éœ“è™¹å…‰æšˆ */
            box-shadow: 0 0 6px rgba(0, 255, 255, 0.4), inset 0 0 4px rgba(0, 255, 255, 0.3);
            padding: 1px 1px; 
            flex-grow: 1;
            /* è®“é¢æ¿åœ¨ç©ºé–“ä¸è¶³æ™‚èƒ½ä¼¸ç¸® */
            flex-basis: 0;
            height: 95%; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--accent-color);
            text-shadow: 1px 1px 0 #000;
            position: relative;
            /* å‚¾æ–œé‚Šè§’æ•ˆæœ */
            transform: skewX(-5deg);
            margin: 0 1px; 
            min-width: 0;
        }

        .hud-panel > * {
            transform: skewX(5deg);
/* å°‡å…§å®¹åå‘å‚¾æ–œï¼Œä¿æŒå‚ç›´ */
        }

        /* èª¿æ•´å­—é«”å¤§å°ç‚ºéŸ¿æ‡‰å¼ï¼Œä¸¦ç¢ºä¿æœ€å°å°ºå¯¸ä¸æœƒéå¤§ */
        .hud-label {
            font-size: clamp(6px, 1vw, 10px); 
            color: #aaa;
            margin-bottom: 1px; 
            text-transform: uppercase;
            text-align: center;
            line-height: 1;
        }

        /* èª¿æ•´å­—é«”å¤§å°ç‚ºéŸ¿æ‡‰å¼ï¼Œä¸¦ç¢ºä¿æœ€å°å°ºå¯¸ä¸æœƒéå¤§ */
        .hud-value {
            font-size: clamp(8px, 2.5vw, 16px); 
            font-weight: bold;
            white-space: nowrap;
        }

        /* ç›®æ¨™é¢æ¿ç‰¹åˆ¥æ¨£å¼ */
        #target-panel {
            flex-basis: 35%; 
            background: var(--bg-color);
            border: 3px solid var(--text-highlight);
            box-shadow: 0 0 12px var(--text-highlight), inset 0 0 8px var(--text-highlight); 
            color: var(--text-highlight);
        }
        
        #target-val {
            font-family: var(--font-title);
            font-weight: 900;
            font-size: clamp(10px, 3.5vw, 22px); 
            line-height: 1.1; 
            word-break: break-word;
        }

        /* HP é¡è‰²å‹•æ…‹èª¿æ•´ */
        #hp-val {
            color: var(--hp-color);
            border-color: var(--hp-color);
        }

        /* ç–ŠåŠ å±¤é€šç”¨æ¨£å¼ (ä½¿ç”¨çµ•å°å®šä½ï¼Œè¦†è“‹åœ¨æ•´å€‹ #game-container ä¸Šæ–¹) */
        .overlay-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(11, 15, 20, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            color: var(--accent-color);
            padding: 20px;
            box-sizing: border-box;
            transition: opacity 0.3s;
        }

        .hidden { 
            opacity: 0;
            pointer-events: none;
            display: none; 
        }

        .doom-title {
            font-size: clamp(24px, 7vw, 50px);
            color: var(--text-highlight);
            text-shadow: 0 0 10px var(--accent-color), 0 0 20px rgba(255, 0, 255, 0.5);
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.5;
            font-family: var(--font-title);
            font-weight: 900;
            border-bottom: 3px dashed var(--accent-color);
            padding-bottom: 10px;
        }

        .btn {
            background: var(--accent-color);
            color: #000;
            border: 2px solid #fff;
            padding: 18px 35px;
            font-family: var(--font-main);
            font-size: clamp(10px, 2vw, 14px);
            cursor: pointer;
            margin-top: 15px;
            /* ç§‘æŠ€æ„ŸæŒ‰éˆ• */
            box-shadow: 0 0 10px var(--accent-color), 0 0 20px var(--accent-color) inset;
            border-radius: 4px;
            transition: transform 0.1s, box-shadow 0.1s, background 0.1s;
            text-align: center;
            line-height: 1.3;
        }
        
        .btn:hover {
            background: #fff;
            color: var(--accent-color);
        }

        .btn:active { 
            transform: translateY(2px);
            box-shadow: 0 0 5px var(--accent-color);
        }

        .btn:disabled {
            background: #555;
            cursor: not-allowed;
            color: #aaa;
            box-shadow: none;
        }

        .level-btns-container, .mode-btns-container, .difficulty-btns-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 90%;
            max-width: 450px;
        }

        /* æ–°å¢ï¼šé›£åº¦é¸æ“‡ container */
        .difficulty-btns-container {
            margin-top: 20px;
            border-top: 2px dashed #444;
            padding-top: 20px;
        }
        
        /* å‚·å®³ç‰¹æ•ˆ */
        #damage-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--danger-color);
            opacity: 0;
            pointer-events: none;
            z-index: 15;
            mix-blend-mode: overlay;
            transition: opacity 0.1s;
        }

        /* æµ®å‹•æ–‡å­— */
        .msg {
            position: absolute;
            font-family: var(--font-title);
            font-weight: 900;
            pointer-events: none;
            animation: popOut 0.8s forwards;
            z-index: 30; 
            white-space: nowrap;
        }
        
        @keyframes popOut {
            0% { transform: translate(-50%, -50%) scale(0.5);
opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.2);
opacity: 1; }
            100% { transform: translate(-50%, -100%) scale(1);
opacity: 0; }
        }

    </style>
</head>
<body>

    <div id="game-container">
        
        <div id="doom-hud">
            <div class="hud-panel">
                <div class="hud-label">STAGE</div>
                <div class="hud-value" id="stage-val">1</div>
            </div>
            
            <div class="hud-panel" style="color:var(--text-highlight);">
                <div class="hud-label">SCORE</div>
                <div class="hud-value" id="score-val">0</div>
            </div>
     
           
            <div class="hud-panel" id="target-panel">
                <div class="hud-label" id="target-title">TARGET PROTOCOL</div>
                <div class="hud-value" id="target-val">--</div>
            </div>
            
            <div class="hud-panel">
     
                <div class="hud-label">PARRY COUNT</div>
                <div class="hud-value" id="parry-val">0/3</div>
            </div>
            
            <div class="hud-panel" id="timer-panel" style="border-color: var(--hp-color);
color: var(--hp-color);">
                <div class="hud-label">TIME</div>
                <div class="hud-value" id="timer-val">0.0</div>
            </div>

            <div class="hud-panel">
                <div class="hud-label">HP CORE</div>
                <div class="hud-value" id="hp-val">100%</div>
   
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="damage-overlay"></div>
        
        <div id="start-screen" class="overlay-screen">
            <div class="doom-title">MATH SLASH<br><span style="font-size:0.6em;
color:#fff;">æ•¸å­¸ä¹‹åˆƒ V2.1</span></div>
            <p style="color:#aaa; font-size:clamp(10px, 1.5vw, 14px); margin-bottom: 20px;
text-align: center;">
                COMBINE NODES TO HIT THE TARGET VALUE.
            </p>
            <button id="start-btn" class="btn" onclick="showModeSelect()" disabled>LOADING...</button>
        </div>
        
        <div id="mode-select-screen" class="overlay-screen hidden">
            <div class="doom-title">SELECT INTERFACE MODE</div>
       
            <p style="color:#fff; font-size:clamp(10px, 1.5vw, 14px); margin-bottom: 20px;
text-align: center;">
                è«‹é¸æ“‡æ‚¨çš„è¼¸å…¥æ¨¡å¼ï¼š
            </p>
            <div class="mode-btns-container">
                <button class="btn" onclick="setInteractionMode('CLICK')">
                    [PC] CLICK MODE (é»æ“Š)<br><span style="font-size:0.7em;
color:#ffff50;">(æ»‘é¼ é»æ“Šæ•¸å­—ç¯€é»é€²è¡Œé¸ä¸­/é…å°)</span>
                </button>
                <button class="btn" onclick="setInteractionMode('SLASH')">
                    [MOBILE] SLASH MODE (æ–¬æ“Š)<br><span style="font-size:0.7em;
color:#ffff50;">(æ»‘å‹•æ‰‹æŒ‡/æ»‘é¼ æ‹–æ›³é€²è¡Œé€£ç·šæ–¬æ“Š)</span>
                </button>
            </div>
        </div>

        <div id="level-select-screen" class="overlay-screen hidden">
            <div class="doom-title">SELECT MISSION TYPE</div>
            <div class="level-btns-container">
                <button class="btn" onclick="selectLevelType('SUM', 'EASY')">
      
                    [TYPE 1] SUM PROTOCOL (åŠ æ³•æ‹†åˆ†)<br><span style="font-size:0.7em;
color:#00ffff;">(æ‰¾å‡ºå…©æ•¸ç›¸åŠ ç­‰æ–¼ç›®æ¨™)</span>
                </button>
                <button id="factor-btn" class="btn" onclick="showDifficultySelect('FACTOR')">
                    [TYPE 2] FACTOR PROTOCOL (å› æ•¸åˆ†è§£)<br><span style="font-size:0.7em;
color:#00ffff;">(é¸æ“‡é›£åº¦)</span>
                </button>
                <button class="btn" onclick="selectLevelType('SEQUENCE', 'EASY')">
                    [TYPE 3] SEQUENCE PROTOCOL (æ•¸åˆ—åç®—)<br><span style="font-size:0.7em;
color:#00ffff;">(å¡«è£œç®—å¼ä¸­çš„å…©å€‹ç¼ºå£ï¼šé‹ç®—ç¬¦è™Ÿèˆ‡æ•¸å­—)</span>
                </button>
            </div>
        </div>

        <div id="difficulty-select-screen" class="overlay-screen hidden">
            <div class="doom-title">FACTOR PROTOCOL: DIFFICULTY</div>
            <p style="color:#fff;
font-size:clamp(10px, 1.5vw, 14px); margin-bottom: 20px; text-align: center;">
                è«‹é¸æ“‡å› æ•¸åˆ†è§£é›£åº¦ï¼š
            </p>
            <div class="difficulty-btns-container">
                <button class="btn" onclick="selectLevelType('FACTOR', 'EASY')">
                    NORMAL MODE<br><span style="font-size:0.7em;
color:#00ffff;">(ç›®æ¨™å€¼ $\le 2000$)</span>
                </button>
                <button class="btn" onclick="selectLevelType('FACTOR', 'HARD')">
                    HARDCORE MODE<br><span style="font-size:0.7em;
color:#fffa50;">(ç›®æ¨™å€¼ $\mathbf{300 \sim 10000}$)</span>
                </button>
            </div>
        </div>

        <div id="ready-screen" class="overlay-screen hidden" style="background: rgba(0,0,0,0.6);">
            <div class="doom-title" style="color:var(--hp-color);">TARGET LOCKED</div>
            <div style="color:#fff;
font-size:clamp(12px, 2vw, 18px); margin-bottom:20px;">INITIATE SEQUENCE?</div>
            <button class="btn" onclick="startRound()">START SLASHING</button>
        </div>

        <div id="clear-screen" class="overlay-screen hidden">
            <div class="doom-title" style="color:var(--hud-border);">PROTOCOL CLEARED</div>
            <p style="color:#fff;
font-size:clamp(12px, 2vw, 16px);">TIME BONUS: <span id="clear-time" style="color:var(--hp-color);">0.00</span>s</p>
            <button class="btn" onclick="nextStage()">NEXT SECTOR</button>
        </div>

        <div id="gameover-screen" class="overlay-screen hidden">
            <div class="doom-title" style="color:var(--danger-color);">MISSION FAILED</div>
            <p style="color:#fff;
font-size:clamp(12px, 2vw, 16px);">FINAL SCORE: <span id="final-score">0</span></p>
            <button class="btn" onclick="showModeSelect()">RETRY</button>
        </div>

    </div>

    <script>
        /**
         * Math Slash Cyberpunk V2.2
         * ä¿®æ­£:
         * 1. ç¢ºä¿ FACTOR æ¨¡å¼çš„æ‰€æœ‰å€™é¸äºº (p1, p2, decoys) éƒ½ä¸å¤§æ–¼ç›®æ¨™å€¼çš„ä¸€åŠ (target / 2)ã€‚
         * 2. å¢åŠ  FACTOR æ¨¡å¼èª˜ç­”æ•¸å­—çš„ã€Œèª˜æƒ‘åŠ›ã€ï¼Œä½¿å…¶æ›´æ¥è¿‘æ­£ç¢ºçš„å› æ•¸ã€‚
         * 3. èª¿æ•´ HTML/CSS çµæ§‹ï¼Œå°‡ HUD å›ºå®šåœ¨ä¸Šå±¤ï¼ŒCanvas å¡«æ»¿ä¸‹å±¤ç©ºé–“ï¼Œä»¥è§£æ±ºæº¢å‡ºå•é¡Œã€‚
         */

        // --- Configuration & Constants ---
        const CONFIG = {
            BASE_WIDTH: 800,   // Reference resolution width
            BASE_HEIGHT: 600,  // Reference resolution height
            CANDIDATE_BASE_SIZE: 50,
            PARRY_NEEDED: 3,
     
            SWIPE_TIMEOUT_MS: 2000,
            TRAIL_LENGTH: 15,
            COLORS: {
                bg: '#0b0f14',
                trail: '#ff00ff', // Slash color (Magenta)
                trailShadow: '#00ffff',
           
                text: '#ffffff',
                highlight: '#fffa50',
                // æ•¸å­—çƒçš„é¡è‰²è¨­å®š
                part1: '#ff00ff', // First selected part color (Magenta)
                part2: '#00ffff', // Second selected part color (Cyan)
              
                decoys: '#444', 
                decoysStroke: '#00ffff'
            },
            // äº’å‹•æ¨¡å¼: ç”±ä½¿ç”¨è€…é¸æ“‡å¾Œè¨­å®š
            INTERACTION_MODE: null
        };
// --- Global State ---
        const state = {
            screen: 'START',
            levelType: 'SUM',
            difficulty: 'EASY', // è¿½è¹¤é›£åº¦
            stage: 1,
            score: 0,
            hp: 100,
     
            parryCount: 0,
            startTime: 0,
            targetValue: 0,
            candidates: [],
            particles: [],
            solutionPair: [], // [val1, val2] æˆ– [op, num]
            partialSelection: null, // First hit candidate
    
            partialTimer: 0,
            scaleFactor: 1,
            pointer: { x: 0, y: 0, isDown: false, trail: [] },
            // æ•¸åˆ—åç®—ç‰¹æœ‰ç‹€æ…‹
            sequenceFound: { op: false, num: false } 
        };
// --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        const hud = document.getElementById('doom-hud');
        const ui = {
            stage: document.getElementById('stage-val'),
            score: document.getElementById('score-val'),
            targetVal: document.getElementById('target-val'),
            targetTitle: document.getElementById('target-title'),
            parry: document.getElementById('parry-val'),
            timer: document.getElementById('timer-val'),
            hp: document.getElementById('hp-val'),
      
            screens: {
                start: document.getElementById('start-screen'),
                mode: document.getElementById('mode-select-screen'),
                level: document.getElementById('level-select-screen'),
                difficulty: document.getElementById('difficulty-select-screen'),
                ready: document.getElementById('ready-screen'),
        
                clear: document.getElementById('clear-screen'),
                gameover: document.getElementById('gameover-screen')
            }
        };
// --- Background Asset ---
        const bgImage = new Image();
        bgImage.src = 'https://placehold.co/1024x768/000/00ffff?text=CYBERNETIC+GRID';
        bgImage.onload = () => {
            document.getElementById('start-btn').disabled = false;
            document.getElementById('start-btn').innerText = "START MISSION";
        };

        // --- Resizing & Responsive Logic ---
        function resize() {
            const w = gameContainer.clientWidth;
            const h = gameContainer.clientHeight;
            const hudHeight = hud.offsetHeight; // æ­£ç¢ºå–å¾— HUD çš„å¯¦éš›é«˜åº¦
            
            // DPI Scaling (Retina support)
            const dpr = window.devicePixelRatio || 1;
            
            // Canvas width/height: å®Œæ•´å¯¬åº¦, é«˜åº¦ç‚ºå®¹å™¨é«˜åº¦æ¸›å» HUD é«˜åº¦ (å®Œç¾å¡«æ»¿ä¸‹æ–¹ç©ºé–“)
            canvas.width = w * dpr;
            canvas.height = (h - hudHeight) * dpr;
            
            // Normalize coordinate system
            ctx.scale(dpr, dpr);
            canvas.style.width = `${w}px`;
            canvas.style.height = `${h - hudHeight}px`;

            // Calculate Scale Factor based on reference resolution
            state.scaleFactor = Math.min(w / CONFIG.BASE_WIDTH, (h - hudHeight) / CONFIG.BASE_HEIGHT) * 1.2;
            if (w < 600) state.scaleFactor *= 1.2;
            
            updateHpDisplay(state.hp);
        }
        window.addEventListener('resize', resize);
        resize();
// --- Input Handling ---

        function getCanvasPos(evt) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function triggerHitCheck(x, y) {
            if (state.screen !== 'PLAYING') return;
            const hitCandidate = getHitCandidate({ x, y });
            if (hitCandidate) {
                processHit(hitCandidate);
            }
        }
        
        function handlePointerDown(e) {
            if (state.screen !== 'PLAYING') return;
            if (e.type === 'mousedown') e.preventDefault(); 
            
            const pos = getCanvasPos(e);
            state.pointer.x = pos.x;
            state.pointer.y = pos.y;
            state.pointer.isDown = true;
            state.pointer.trail = [{x: pos.x, y: pos.y}];
            
            if (CONFIG.INTERACTION_MODE === 'CLICK') {
                triggerHitCheck(pos.x, pos.y);
            }
        }

        function handlePointerMove(e) {
            if (!state.pointer.isDown || state.screen !== 'PLAYING') return;
            e.preventDefault(); 
            
            const pos = getCanvasPos(e);
            
            state.pointer.trail.push({x: pos.x, y: pos.y});
            if (state.pointer.trail.length > CONFIG.TRAIL_LENGTH) {
                state.pointer.trail.shift();
            }

            if (CONFIG.INTERACTION_MODE === 'SLASH') {
                checkLineCollision(state.pointer.x, state.pointer.y, pos.x, pos.y);
            }

            state.pointer.x = pos.x;
            state.pointer.y = pos.y;
        }

        function handlePointerUp(e) {
            state.pointer.isDown = false;
            state.pointer.trail = [];
        }

        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mousemove', handlePointerMove);
        window.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('touchstart', handlePointerDown, {passive: false});
        canvas.addEventListener('touchmove', handlePointerMove, {passive: false});
        window.addEventListener('touchend', handlePointerUp);
// --- Game Logic Classes (Unchanged) ---
        
        class Candidate {
            constructor(val, solutionKey, type='number') {
                this.text = String(val);
                this.solutionKey = solutionKey; // 'P1', 'P2', 'DECOY'
                this.dataType = type;
                // 'number', 'operator', or 'mix'
                
                this.radius = (CONFIG.CANDIDATE_BASE_SIZE / 2) * state.scaleFactor;
                const w = canvas.width / (window.devicePixelRatio || 1);
                const h = canvas.height / (window.devicePixelRatio || 1);
                const margin = this.radius * 2;
                
                // Position finding logic...
                let attempts = 0;
                let safe = false;
                while(!safe && attempts < 50) {
                    this.x = margin + Math.random() * (w - margin * 2);
                    this.y = margin + Math.random() * (h - margin * 2);
                    
                    safe = true;
                    for (let c of state.candidates) {
                        const dist = Math.hypot(this.x - c.x, this.y - c.y);
                        if (dist < (this.radius + c.radius) * 1.5) { 
                            safe = false;
                            break;
                        }
                    }
                    attempts++;
                }

                // Random velocity (scaled)
                const speed = (0.5 + Math.random() * 1.0) * state.scaleFactor;
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.highlighted = false;
                this.selected = false;
                this.scaleAnim = 1;
            }

            update() {
                const w = canvas.width / (window.devicePixelRatio || 1);
                const h = canvas.height / (window.devicePixelRatio || 1);

                this.x += this.vx;
                this.y += this.vy;
                // Boundary bounce
                if (this.x < this.radius) { this.x = this.radius;
                this.vx *= -1; }
                if (this.x > w - this.radius) { this.x = w - this.radius;
                this.vx *= -1; }
                if (this.y < this.radius) { this.y = this.radius;
                this.vy *= -1; }
                if (this.y > h - this.radius) { this.y = h - this.radius;
                this.vy *= -1; }

                if (this.selected) {
                    this.scaleAnim = 1 + Math.sin(Date.now() / 100) * 0.1;
                } else {
                    this.scaleAnim = 1;
                }
            }

            draw() {
                const r = this.radius * this.scaleAnim;
                ctx.save();
                ctx.translate(this.x, this.y);

                // Cyberpunk Glow Effect
                ctx.shadowBlur = this.highlighted ||
                this.selected ? 30 : 10;
                const glowColor = this.selected ? (this.solutionKey === 'P1' ? CONFIG.COLORS.part1 : CONFIG.COLORS.part2) : CONFIG.COLORS.decoysStroke;
                ctx.shadowColor = glowColor;

                // Fill
                ctx.fillStyle = this.selected ?
                'rgba(0,0,0,0.8)' : CONFIG.COLORS.decoys;
                
                // Border Color based on selection part
                let strokeColor = CONFIG.COLORS.decoysStroke;
                if (this.selected) {
                    strokeColor = this.solutionKey === 'P1' ?
                    CONFIG.COLORS.part1 : CONFIG.COLORS.part2;
                } else if (this.highlighted) {
                    strokeColor = CONFIG.COLORS.highlight;
                }

                ctx.lineWidth = 4 * state.scaleFactor;
                ctx.strokeStyle = strokeColor;

                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                // Text
                ctx.shadowBlur = 0;
                ctx.fillStyle = this.selected ? '#fff' : strokeColor; 
                ctx.font = `${Math.floor(20 * state.scaleFactor)}px "Press Start 2P"`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, 0, 2 * state.scaleFactor);

                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 * state.scaleFactor;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = 0.03;
                this.size = (Math.random() * 4 + 2) * state.scaleFactor;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // --- Screen Management ---

        function switchScreen(screenName) {
            state.screen = screenName;
            Object.values(ui.screens).forEach(el => el.classList.add('hidden'));
            
            if (screenName === 'START') ui.screens.start.classList.remove('hidden');
            if (screenName === 'MODE_SELECT') ui.screens.mode.classList.remove('hidden');
            if (screenName === 'LEVEL_SELECT') ui.screens.level.classList.remove('hidden');
            if (screenName === 'DIFFICULTY_SELECT') ui.screens.difficulty.classList.remove('hidden');
            if (screenName === 'READY') ui.screens.ready.classList.remove('hidden');
            if (screenName === 'CLEARED') ui.screens.clear.classList.remove('hidden');
            if (screenName === 'GAMEOVER') ui.screens.gameover.classList.remove('hidden');
        }

        function showModeSelect() { 
            switchScreen('MODE_SELECT');
        }

        function setInteractionMode(mode) {
            CONFIG.INTERACTION_MODE = mode;
            showLevelSelect();
        }

        function showLevelSelect() { 
            switchScreen('LEVEL_SELECT');
        }

        function showDifficultySelect(type) {
            if (type === 'FACTOR') {
                switchScreen('DIFFICULTY_SELECT');
            } else {
                selectLevelType(type, 'EASY');
            }
        }
        
        function selectLevelType(type, difficulty) {
            state.levelType = type;
            state.difficulty = difficulty;
            startGame();
        }

        function startGame() {
            state.stage = 1;
            state.score = 0;
            state.hp = 100;
            ui.score.innerText = '0';
            updateHpDisplay(100);
            setupStage();
        }

        function setupStage() {
            state.parryCount = 0;
            state.partialSelection = null;
            state.candidates = [];
            state.particles = [];
            state.sequenceFound = { op: false, num: false };
            ui.stage.innerText = `${state.stage} (${state.difficulty.substring(0, 1)})`;
            ui.parry.innerText = `0/${CONFIG.PARRY_NEEDED}`;
            ui.timer.innerText = "0.0";
            // Generate Data
            const data = generateLevelData(state.levelType, state.stage, state.difficulty);
            state.targetValue = data.target;
            state.solutionPair = data.pair;
            
            // Setup UI Display
            ui.targetTitle.innerText = state.levelType + (state.difficulty === 'HARD' ? ' (HARD)' : ' (NORMAL)');
            ui.targetVal.innerHTML = formatTargetValue(state.targetValue, state.levelType);

            // Spawn Candidates
            state.candidates.push(new Candidate(data.pair[0], 'P1', data.type));
            state.candidates.push(new Candidate(data.pair[1], 'P2', data.type));
            // Decoys
            data.decoys.forEach(decoy => {
                state.candidates.push(new Candidate(decoy, 'DECOY', data.type));
            });
            switchScreen('READY');
        }

        function formatTargetValue(target, type) {
            if (type === 'SEQUENCE') {
                const parts = target.split(' ');
                // æ›¿æ›å•è™Ÿï¼Œç´…å•è™Ÿ for Op, è—å•è™Ÿ for Num
                parts[1] = `<span style="color:${CONFIG.COLORS.part1};">${state.sequenceFound.op ?
                parts[1] : '?'}</span>`;
                parts[2] = `<span style="color:${CONFIG.COLORS.part2};">${state.sequenceFound.num ? parts[2] : '?'}</span>`;
                return parts.join(' ');
            }
            return target;
        }

        function startRound() {
            switchScreen('PLAYING');
            state.startTime = performance.now();
        }

        function nextStage() {
            state.stage++;
            setupStage();
        }

        function updateHpDisplay(hp) {
            state.hp = hp;
            ui.hp.innerText = state.hp + "%";
            
            let color = 'var(--hp-color)'; // Default: Green
            if (hp <= 50) color = '#ffaa00';
            // Yellow/Orange
            if (hp <= 20) color = 'var(--danger-color)';
            // Red
            
            gameContainer.style.setProperty('--hp-color', color);
            ui.hp.style.color = color;
        }

        // --- Collision & Interaction ---

        function getHitCandidate({x, y}) {
            for (let c of state.candidates) {
                const dx = x - c.x;
                const dy = y - c.y;
                if (dx*dx + dy*dy < c.radius * c.radius) {
                    return c;
                }
            }
            return null;
        }

        function checkLineCollision(x1, y1, x2, y2) {
            for (let c of state.candidates) {
                if (c.selected && c === state.partialSelection) continue;
                const dist = pointToSegmentDistance(c.x, c.y, x1, y1, x2, y2);
                if (dist < c.radius) {
                    processHit(c);
                    return; 
                }
            }
        }

        function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
            const l2 = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
            if (l2 === 0) return Math.hypot(px-x1, py-y1);
            let t = ((px-x1)*(x2-x1) + (py-y1)*(y2-y1)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(px - (x1 + t * (x2-x1)), py - (y1 + t * (y2-y1)));
        }

        function processHit(candidate) {
            if (candidate.highlighted) return;
            candidate.highlighted = true;
            setTimeout(() => candidate.highlighted = false, 150);
            
            spawnParticles(candidate.x, candidate.y, CONFIG.COLORS.highlight);
            if (state.levelType === 'SEQUENCE') {
                handleSequenceHit(candidate);
                return;
            }

            // --- SUM/FACTOR Logic ---
            const isSolutionPart = (candidate.solutionKey === 'P1' || candidate.solutionKey === 'P2');
            if (!isSolutionPart) {
                handleFail("WRONG NODE!", 20);
                return;
            }

            // Deselection
            if (state.partialSelection === candidate) {
                state.partialSelection.selected = false;
                state.partialSelection = null;
                showFloatMsg(candidate.x, candidate.y, "CANCELLED", false);
                return;
            }

            if (state.partialSelection === null) {
                // First Hit
                state.partialSelection = candidate;
                candidate.selected = true;
                state.partialTimer = Date.now();
                showFloatMsg(candidate.x, candidate.y, "NODE LOCKED", true);
            } else {
                // Second Hit - Check if it's the remaining part
                const otherKey = state.partialSelection.solutionKey === 'P1' ?
                'P2' : 'P1';
                if (candidate.solutionKey === otherKey) {
                    // Success!
                    scoreSuccess(candidate.x, candidate.y);
                } else {
                    // Two correct nodes but same key (impossible with current generation) or already used key
                    handleFail("PROTOCOL MISMATCH!", 15);
                }
            }
        }
        
        function handleSequenceHit(candidate) {
            const isOp = ['+', '-', 'x', '/'].includes(candidate.text);
            const isNum = !isOp;

            let solved = false;
            
            if (candidate.solutionKey === 'P1' && isOp && !state.sequenceFound.op) {
                // Correct Operator
                state.sequenceFound.op = true;
                solved = true;
            } else if (candidate.solutionKey === 'P2' && isNum && !state.sequenceFound.num) {
                // Correct Number
                state.sequenceFound.num = true;
                solved = true;
            } else if (candidate.solutionKey === 'DECOY') {
                // Decoy hit
                handleFail("DATA CORRUPTION!", 15);
                return;
            } else if (candidate.solutionKey === 'P1' && isOp && state.sequenceFound.op) {
                // Already found operator
                showFloatMsg(candidate.x, candidate.y, "ALREADY RESOLVED", false);
                return;
            } else if (candidate.solutionKey === 'P2' && isNum && state.sequenceFound.num) {
                // Already found number
                showFloatMsg(candidate.x, candidate.y, "ALREADY RESOLVED", false);
                return;
            } else {
                // Hitting wrong type (e.g., hitting operator P1 with a number)
                handleFail("TYPE MISMATCH!", 15);
                return;
            }

            if (solved) {
                // Successfully found one part
                showFloatMsg(candidate.x, candidate.y, "RESOLVED!", true);
                // Remove the candidate node
                state.candidates = state.candidates.filter(c => c !== candidate);
                // Update target display
                ui.targetVal.innerHTML = formatTargetValue(state.targetValue, state.levelType);
                // Check for completion
                if (state.sequenceFound.op && state.sequenceFound.num) {
                    scoreSuccess(candidate.x, candidate.y);
                }
            }
        }

        function scoreSuccess(x, y) {
            state.score += 100 + Math.floor(state.hp / 10);
            ui.score.innerText = state.score;
            state.parryCount++;
            ui.parry.innerText = `${state.parryCount}/${CONFIG.PARRY_NEEDED}`;
            
            showFloatMsg(x, y, state.levelType === 'SEQUENCE' ? "COMPLETED!" : "PARRY!", true);
            spawnParticles(x, y, '#00ff00');
            if(state.partialSelection) state.partialSelection.selected = false;
            state.partialSelection = null;

            if (state.parryCount >= CONFIG.PARRY_NEEDED) {
                handleClear();
            } else {
                setTimeout(respawnCandidates, 500);
            }
        }

        function handleFail(msg, damage) {
            const newHp = state.hp - damage;
            updateHpDisplay(newHp);
            
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = 0.8;
            setTimeout(() => overlay.style.opacity = 0, 150);
            
            showFloatMsg(canvas.width/2, canvas.height/2, msg, false);
            if(state.partialSelection) state.partialSelection.selected = false;
            state.partialSelection = null;

            if (newHp <= 0) {
                switchScreen('GAMEOVER');
                document.getElementById('final-score').innerText = state.score;
            }
        }

        function handleClear() {
            state.score += 500;
            const time = (performance.now() - state.startTime) / 1000;
            document.getElementById('clear-time').innerText = time.toFixed(2);
            switchScreen('CLEARED');
        }

        function respawnCandidates() {
            const count = state.candidates.length;
            const data = generateLevelData(state.levelType, state.stage, state.difficulty);
            
            state.targetValue = data.target;
            state.solutionPair = data.pair;
            
            ui.targetVal.innerHTML = formatTargetValue(state.targetValue, state.levelType);

            state.candidates = [];
            state.sequenceFound = { op: false, num: false }; 

            state.candidates.push(new Candidate(data.pair[0], 'P1', data.type));
            state.candidates.push(new Candidate(data.pair[1], 'P2', data.type));
            data.decoys.forEach(decoy => {
                state.candidates.push(new Candidate(decoy, 'DECOY', data.type));
            });
        }

        function showFloatMsg(x, y, text, good) {
            const el = document.createElement('div');
            el.className = 'msg';
            el.innerText = text;
            
            const canvasRect = canvas.getBoundingClientRect();
            // æ³¨æ„ï¼šé€™è£¡ä½¿ç”¨ canvasRect.top æ˜¯å› ç‚ºæµ®å‹•è¨Šæ¯æ˜¯ç›¸å°æ–¼æ•´å€‹æ–‡æª”çš„
            // ç”±æ–¼ canvas å·²ç¶“åœ¨ HUD ä¸‹æ–¹ï¼Œæ‰€ä»¥ y åº§æ¨™æœƒè‡ªå‹•åŠ ä¸Š HUD çš„é«˜åº¦
            el.style.left = (x + canvasRect.left) + 'px';
            el.style.top = (y + canvasRect.top) + 'px'; 
            
            el.style.color = good ? 'var(--hp-color)' : 'var(--danger-color)';
            el.style.textShadow = good ?
            '0 0 5px var(--hp-color)' : '0 0 5px var(--danger-color)';
            el.style.fontSize = (20 * state.scaleFactor) + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function spawnParticles(x, y, color) {
            for(let i=0; i<10; i++) {
                state.particles.push(new Particle(x, y, color));
            }
        }

        // --- Data Generation (æ ¸å¿ƒä¿®æ”¹è™•) ---

        function generateLevelData(type, stage, difficulty) {
            const baseCount = Math.min(8 + Math.floor(stage / 2), 12);
            let decoys = [];

            if (type === 'SUM') {
                const base = Math.pow(10, Math.floor(Math.random()*2)+1);
                const target = Math.floor(Math.random()*8 + 2) * base;
                let p1 = Math.floor(Math.random() * target * 0.8) + (target*0.1);
                p1 = Math.floor(p1);
                let p2 = target - p1;
                
                while(decoys.length < baseCount - 2) {
                    const decoy = Math.floor(Math.random()*target * 1.5);
                    if (decoy !== p1 && decoy !== p2 && decoy > 0) decoys.push(decoy);
                }
                return { target: target, pair: [p1, p2], decoys: decoys, type: 'number' };
            }
            else if (type === 'FACTOR') {
                let minTarget, maxTarget, maxFactor;
                if (difficulty === 'HARD') {
                    minTarget = 300;
                    maxTarget = 10000;
                    maxFactor = 50;
                } else {
                    minTarget = 4;
                    maxTarget = 2000;
                    maxFactor = 15;
                }

                let p1, p2, target;
                let foundPair = false;

                // 1. ç¢ºä¿ç”Ÿæˆç›®æ¨™å€¼ (target)
                while(!foundPair) {
                    // p1 and p2 must be at least 2 for non-trivial factor
                    p1 = Math.floor(Math.random() * maxFactor) + 2;
                    p2 = Math.floor(Math.random() * maxFactor) + 2; 
                    target = p1 * p2;
                    if (target >= minTarget && target <= maxTarget) {
                        foundPair = true;
                    }
                }
                
                // ç¢ºä¿ p1 <= p2
                const p_min = Math.min(p1, p2);
                const p_max = Math.max(p1, p2);
                
                // 2. ç¢ºå®šæ‰€æœ‰å€™é¸äººçš„æœ€å¤§å€¼é™åˆ¶ (target / 2)
                // ç”±æ–¼ p_min >= 2ï¼Œp_max ä¸€å®š <= target / 2
                const max_val = Math.floor(target / 2);
                // 3. æ ¹æ“šç›®æ¨™å¤§å°å‹•æ…‹èª¿æ•´èª˜ç­”ç¯„åœ (proximity_range)
                // å›°é›£æ¨¡å¼ä¸‹ç›®æ¨™å¤§ï¼Œç¯„åœå¯ä»¥å¯¬ä¸€é»ï¼Œæ™®é€šæ¨¡å¼ç›®æ¨™å°ï¼Œç¯„åœçª„ä¸€é»ã€‚
                const proximity_range = Math.max(5, Math.floor(Math.sqrt(target) / 3));
                const required_decoys_count = baseCount - 2;

                // 4. ç”Ÿæˆèª˜ç­”æ•¸å­—
                while (decoys.length < required_decoys_count) {
                    let decoy = -1;
                    const rng = Math.random();

                    if (rng < 0.35) {
                        // 35% chance: èª˜ç­”æ•¸å­—æ¥è¿‘ p_max (è¼ƒå¤§çš„å› æ•¸)
                        const min_d = Math.max(2, p_max - proximity_range);
                        // æœ€å¤§å€¼ä¸å¯è¶…é max_val (target/2)ï¼Œä¹Ÿä¸èƒ½è¶…é p_max + range
                        const max_d = Math.min(max_val, p_max + proximity_range);
                        if (min_d >= max_d) { decoy = min_d; } 
                        else { decoy = Math.floor(Math.random() * (max_d - min_d + 1)) + min_d;
                        }
                    } else if (rng < 0.70) {
                        // 35% chance: èª˜ç­”æ•¸å­—æ¥è¿‘ p_min (è¼ƒå°çš„å› æ•¸)
                        const min_d = Math.max(2, p_min - proximity_range);
                        const max_d = Math.min(max_val, p_min + proximity_range);
                        
                        if (min_d >= max_d) { decoy = min_d;
                        }
                        else { decoy = Math.floor(Math.random() * (max_d - min_d + 1)) + min_d;
                        }
                    } else {
                        // 30% chance: éš¨æ©Ÿé¸å–ä¸€å€‹æ•¸å­—ï¼Œä½†ä¿è­‰åœ¨ [2, max_val] ä¹‹é–“ï¼Œå¢åŠ å¤šæ¨£æ€§
                        const min_d = 2;
                        const max_d = max_val;
                        if (min_d >= max_d) { decoy = min_d;
                        }
                        else { decoy = Math.floor(Math.random() * (max_d - min_d + 1)) + min_d;
                        }
                    }

                    // é©—è­‰æ¢ä»¶ï¼š
                    if (decoy > 1 && 
                        target % decoy !== 0 &&     
                        // å¿…é ˆä¸æ˜¯ç›®æ¨™çš„å› æ•¸
                        decoy !== p_min &&              // å¿…é ˆä¸æ˜¯æ­£ç¢ºç­”æ¡ˆ p_min
                        decoy !== p_max &&              // å¿…é ˆä¸æ˜¯æ­£ç¢ºç­”æ¡ˆ p_max
         
                        !decoys.includes(decoy)         // å¿…é ˆæ˜¯å”¯ä¸€çš„
                    ) {
                        decoys.push(decoy);
                    }
                }

                return { target: target, pair: [p_min, p_max], decoys: decoys, type: 'number' };
            }
            else {
                // SEQUENCE æ•¸åˆ—åç®— (é›£åº¦ç¶­æŒ EASY)
                const ops = ['+', '-', 'x', '/'];
                const op = ops[Math.floor(Math.random()*ops.length)];
                
                let n1, n2, res;
                let valid = false;
                while(!valid) {
                    n1 = Math.floor(Math.random()*15) + 5;
                    n2 = Math.floor(Math.random()*15) + 1;

                    if(op === '+') res = n1 + n2;
                    if(op === '-') res = n1 - n2;
                    if(op === 'x') res = n1 * n2;
                    if (op === '/') {
                        n1 = n2 * (Math.floor(Math.random()*8) + 2);
                        res = n1 / n2;
                    }

                    if (res > 0 && Number.isInteger(res) && n1 > 0 && n2 > 0) {
                        valid = true;
                    }
                }
                
                const displayText = `${n1} ? ? = ${res}`; // ä¿®æ­£é¡¯ç¤ºéŒ¯èª¤
                
                const solutionOp = op;
                const solutionNum = n2;
                
                const decoyOps = ops.filter(o => o !== solutionOp).slice(0, 2);
                const decoyNums = [];
                while(decoyNums.length < 2) {
                    const decoy = Math.floor(Math.random()*20) + 1;
                    if (decoy !== solutionNum) decoyNums.push(decoy);
                }

                const allDecoys = [...decoyOps, ...decoyNums];
                return { target: displayText, pair: [solutionOp, solutionNum], decoys: allDecoys, type: 'mix' };
            }
        }


        // --- Main Loop ---
        function loop() {
            requestAnimationFrame(loop);
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            ctx.fillStyle = CONFIG.COLORS.bg;
            ctx.fillRect(0, 0, w, h);
            
            // Draw background grid effect
            ctx.globalAlpha = 0.2;
            const gridSize = 40 * state.scaleFactor;
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 0.5;
            for(let x = 0; x < w; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for(let y = 0; y < h; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }
            ctx.globalAlpha = 1.0;
            if (state.screen === 'PLAYING') {
                ui.timer.innerText = ((performance.now() - state.startTime)/1000).toFixed(1);
                state.candidates.forEach(c => {
                    c.update();
                    c.draw();
                });
                if (state.partialSelection && state.levelType !== 'SEQUENCE') {
                    if (Date.now() - state.partialTimer > CONFIG.SWIPE_TIMEOUT_MS) {
                        state.partialSelection.selected = false;
                        state.partialSelection = null;
                        handleFail("DATA LINK EXPIRED!", 10); 
                    }
                }
            }

            state.particles = state.particles.filter(p => p.life > 0);
            state.particles.forEach(p => { p.update(); p.draw(); });

            // Draw Trail (Slash Effect)
            if (state.pointer.isDown && state.pointer.trail.length > 1 && CONFIG.INTERACTION_MODE === 'SLASH') {
                ctx.beginPath();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = 6 * state.scaleFactor;
                ctx.strokeStyle = CONFIG.COLORS.trail;
                ctx.shadowBlur = 15;
                ctx.shadowColor = CONFIG.COLORS.trailShadow;
                const trail = state.pointer.trail;
                ctx.moveTo(trail[0].x, trail[0].y);
                
                // Quadratic bezier for smooth curve
                for (let i = 1; i < trail.length - 1; i++) {
                    const xc = (trail[i].x + trail[i+1].x) / 2;
                    const yc = (trail[i].y + trail[i+1].y) / 2;
                    ctx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);
                }
                if(trail.length > 2) ctx.lineTo(trail[trail.length-1].x, trail[trail.length-1].y);
                ctx.stroke();
                ctx.shadowBlur = 0; 
            }
        }

        // Initialize
        loop();
    </script>
</body>
</html>
