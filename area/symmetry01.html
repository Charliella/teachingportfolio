<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk å°ç¨±ç¹ªåœ–å·¥å…· (å·²ä¿®æ­£)</title>
    <style>
        /* --- æ•´é«”å¤œé–“æ¨¡å¼æ¨£å¼ --- */
        body {
            font-family: 'Arial', sans-serif;
            text-align: center;
            padding: 20px;
            margin: 0;
            background-color: #1a1a2e; 
            color: #e9f1f8; 
        }
        h1 {
            color: #00ffc4; 
            text-shadow: 0 0 5px #00ffc4;
        }
        p {
            color: #99ffff; /* ç‹€æ…‹æ–‡å­—æ”¹ç‚ºæ›´æŸ”å’Œçš„äº®è—è‰² */
        }
        #drawingCanvas {
            width: 90%; 
            max-width: 800px;
            height: 500px;
            border: 2px solid #00ffc4; 
            background-color: #0d0d1a; 
            cursor: default; 
            margin: 10px auto;
            display: block; 
            touch-action: none; 
            box-shadow: 0 0 10px rgba(0, 255, 196, 0.5); 
        }
        /* --- æŒ‰éˆ•æ¨£å¼ (Cyberpunk é¢¨æ ¼) --- */
        .controls { margin-bottom: 20px; }
        .controls button {
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            border: 2px solid;
            border-radius: 4px;
            margin: 5px;
            transition: all 0.2s;
            box-shadow: 0 0 5px;
        }
        #toggleButton { 
            background-color: #28a74520; 
            color: #00ffc4; 
            border-color: #00ffc4;
            box-shadow: 0 0 5px #00ffc4;
        } 
        #setAxisButton { 
            background-color: #ffc10720; 
            color: #ff9900; /* æ”¹ç‚ºè¼ƒæŸ”å’Œçš„æ©˜è‰² */
            border-color: #ff9900;
            box-shadow: 0 0 5px #ff9900;
        } 
        #clearButton { 
            background-color: #007bff20; 
            color: #ff33cc; 
            border-color: #ff33cc;
            box-shadow: 0 0 5px #ff33cc;
        } 
        .controls button:hover {
            transform: translateY(-2px);
            opacity: 0.9;
        }
    </style>
</head>
<body>

    <h1>è‡ªç”±ç›´ç·šå°ç¨±ç¹ªåœ–å·¥å…· :: AXIS_CONTROL</h1>
    <p id="statusText">è«‹é»æ“Š **è¨­å®šå°ç¨±è»¸** æŒ‰éˆ•ä¾†å®šç¾©æ‚¨çš„é¡åƒè»¸ï¼ˆéœ€é»æ“Šå…©æ¬¡ï¼‰ã€‚</p>

    <div class="controls">
        <button id="setAxisButton">ğŸ“Œ è¨­å®šå°ç¨±è»¸ (1/2)</button>
        <button id="toggleButton">ğŸ–Œï¸ é»æ­¤é–‹å§‹ç¹ªè£½</button>
        <button id="clearButton">ğŸ—‘ï¸ æ¸…é™¤ç•«å¸ƒ</button>
    </div>

    <canvas id="drawingCanvas"></canvas>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const toggleButton = document.getElementById('toggleButton');
        const setAxisButton = document.getElementById('setAxisButton');
        const clearButton = document.getElementById('clearButton');
        const statusText = document.getElementById('statusText');

        let isDrawing = false;
        let isDrawingMode = false; 
        let isSettingAxisP1 = false; 
        let isSettingAxisP2 = false; 

        let symmetryP1 = null; 
        let symmetryP2 = null; 
        let angle = 0;         

        let lastX = 0;
        let lastY = 0;
        
        // ã€ä¿®æ­£ä¸€ï¼šç¹ªåœ–æ­·å²ç´€éŒ„ã€‘
        // å„²å­˜ç”¨æˆ¶ç•«çš„æ‰€æœ‰ç·šæ®µï¼Œä»¥ä¾¿åœ¨å‹•ç•«æ™‚é‡ç¹ª
        let drawingHistory = []; 

        // --- å‹•ç•«ç›¸é—œè®Šæ•¸ ---
        let animationFrameId = null; 
        let flickerState = 0;        
        
        // --- ç¹ªåœ–æ¨£å¼è¨­å®š ---
        const USER_STROKE_COLOR = '#33ccff'; // ç”¨æˆ¶ç¹ªè£½ç·šæ¢é¡è‰² (å¤©è—è‰²)
        const AXIS_PRIMARY_COLOR = '#00ffc4'; // è»¸ç·šä¸»è‰² (éœ“è™¹ç¶ )
        const AXIS_FLICKER_COLOR = '#99ffff'; // è»¸ç·šé–ƒçˆè¼”è‰² (æŸ”å’Œäº®ç™½)

        ctx.strokeStyle = USER_STROKE_COLOR; 
        ctx.lineWidth = 5;           
        ctx.lineCap = 'round';       

        // --- æ ¸å¿ƒä¿®æ­£å‡½æ•¸ï¼šé‡ç¹ªç”¨æˆ¶ç·šæ¢ ---
        function redrawUserStrokes() {
            ctx.strokeStyle = USER_STROKE_COLOR;
            ctx.lineWidth = 5;
            ctx.globalAlpha = 1.0;
            ctx.setLineDash([]); // ç¢ºä¿ç”¨æˆ¶ç¹ªåœ–æ˜¯å¯¦ç·š

            drawingHistory.forEach(segment => {
                ctx.beginPath();
                ctx.moveTo(segment.x1, segment.y1);
                ctx.lineTo(segment.x2, segment.y2);
                ctx.stroke();
            });
        }
        
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // ç”±æ–¼å‹•ç•«å¾ªç’°æœƒè™•ç†æ¸…é™¤å’Œé‡ç¹ªï¼Œé€™è£¡åªç¢ºä¿å°ºå¯¸æ­£ç¢º
            
            if (symmetryP1 && symmetryP2) {
                stopFlickerAnimation();
                startFlickerAnimation();
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                redrawUserStrokes();
            }

            ctx.strokeStyle = USER_STROKE_COLOR; 
            ctx.lineWidth = 5; 
            ctx.lineCap = 'round';
        }

        // ç¹ªè£½å°ç¨±è»¸ç·š (P1 åˆ° P2)
        function drawSymmetryLine(p1, p2) {
            
            // ã€ä¿®æ­£äºŒï¼šæŸ”å’Œé–ƒçˆã€‘
            flickerState = (flickerState + 1) % 60; // é€±æœŸ 60 å¹€
            
            // é¡è‰²èˆ‡é€æ˜åº¦æŸ”å’Œè®ŠåŒ–
            const isFlicker = (flickerState % 15 < 3); // é™ä½é–ƒçˆé »ç‡
            ctx.strokeStyle = isFlicker ? AXIS_FLICKER_COLOR : AXIS_PRIMARY_COLOR;
            ctx.lineWidth = isFlicker ? 2 : 1.5; // ç·šå¯¬è®ŠåŒ–è¼ƒå°
            ctx.globalAlpha = isFlicker ? 0.9 : 0.7; // é€æ˜åº¦è®ŠåŒ–è¼ƒå°
            
            // è™›ç·šé•·åº¦å‹•æ…‹è®ŠåŒ–
            ctx.setLineDash([(flickerState % 10) + 5, (flickerState % 5) + 5]); 
            
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();

            // æ¨™ç¤º P1 å’Œ P2 (å›ºå®šæ¨£å¼) - åœ¨å‹•ç•«å¾ªç’°ä¸­ç¹ªè£½
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = '#ff9900';
            
            // P1 æ¨™è¨˜
            ctx.shadowColor = '#ff33cc'; // P1 ä½¿ç”¨ç²‰è‰²å…‰
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(p1.x, p1.y, 7, 0, 2 * Math.PI);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#e9f1f8';
            ctx.beginPath();
            ctx.arc(p1.x, p1.y, 3, 0, 2 * Math.PI);
            ctx.fill();

            // P2 æ¨™è¨˜
            ctx.fillStyle = '#ff9900'; // P2 ä½¿ç”¨æ©˜è‰²å…‰
            ctx.shadowColor = '#ff9900';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(p2.x, p2.y, 7, 0, 2 * Math.PI);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#e9f1f8';
            ctx.beginPath();
            ctx.arc(p2.x, p2.y, 3, 0, 2 * Math.PI);
            ctx.fill();

            // é‡ç½®é™°å½±ï¼Œé¿å…å½±éŸ¿å¾ŒçºŒç¹ªåœ–
            ctx.shadowBlur = 0;
        }
        
        // --- é–ƒçˆå‹•ç•«æ§åˆ¶ ---
        function flickerAnimationLoop() {
            // ã€ä¿®æ­£ä¸€ï¼šä¿ç•™ç·šæ¢çš„é—œéµæ­¥é©Ÿã€‘
            ctx.clearRect(0, 0, canvas.width, canvas.height); // 1. æ¸…é™¤ç•«å¸ƒ
            redrawUserStrokes();                             // 2. é‡ç¹ªç”¨æˆ¶ç·šæ¢
            
            if (symmetryP1 && symmetryP2) {
                drawSymmetryLine(symmetryP1, symmetryP2);    // 3. ç¹ªè£½é–ƒçˆè»¸ç·š (åŒ…å« P1, P2 æ¨™è¨˜)
            }
            
            animationFrameId = requestAnimationFrame(flickerAnimationLoop);
        }

        function startFlickerAnimation() {
            if (animationFrameId) stopFlickerAnimation();
            animationFrameId = requestAnimationFrame(flickerAnimationLoop);
        }

        function stopFlickerAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);

        // --- ã€æ–°å¢å‡½æ•¸ã€‘å³æ™‚ç¹ªè£½å–®å€‹é»çš„æ¨™è¨˜ (è¨­å®šè»¸ç·šæ™‚ç”¨) ---
        function drawAxisPointMarker(x, y, color = '#ff33cc') {
            // æ¸…é™¤ç•«å¸ƒå’Œé‡ç¹ªç”¨æˆ¶ç·šæ¢ï¼Œä»¥ç¢ºä¿é»ä½åœ¨æœ€ä¸Šå±¤
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            redrawUserStrokes(); 
            
            // ç¹ªè£½é»ä½ (Cyberpunk ç™¼å…‰æ•ˆæœ)
            ctx.globalAlpha = 1.0;
            
            // é»ä½å¤–ç’° (ç™¼å…‰æ•ˆæœ)
            ctx.shadowColor = color;
            ctx.shadowBlur = 8;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 7, 0, 2 * Math.PI);
            ctx.fill();
            
            // é»ä½æ ¸å¿ƒ
            ctx.shadowBlur = 0; // ç§»é™¤é™°å½±
            ctx.fillStyle = '#e9f1f8'; // ç™½è‰²æ ¸å¿ƒ
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, 2 * Math.PI);
            ctx.fill();

            // é‡ç½®é™°å½±
            ctx.shadowBlur = 0;
        }


        // --- æ ¸å¿ƒå¹¾ä½•è¨ˆç®—å‡½æ•¸ (ä¿æŒä¸è®Š) ---
        function getMirrorPoint(x, y) {
            // ... (å¹¾ä½•åå°„è¨ˆç®—ï¼Œä¿æŒä¸è®Š) ...
            if (!symmetryP1 || !symmetryP2) return {x, y};
            const x1 = symmetryP1.x;
            const y1 = symmetryP1.y;
            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);
            const tx = x - x1;
            const ty = y - y1;
            const rx = tx * cosA + ty * sinA;
            const ry = ty * cosA - tx * sinA;
            const reflected_ry = -ry;
            const r2x = rx * cosA - reflected_ry * sinA;
            const r2y = rx * sinA + reflected_ry * cosA;
            const finalX = r2x + x1;
            const finalY = r2y + y1;
            return { x: finalX, y: finalY };
        }


        // --- æ ¸å¿ƒç¹ªåœ–é‚è¼¯ (è¨˜éŒ„ç·šæ®µ) ---
        function symmetricalDraw(x, y) {
            if (!isDrawing || !symmetryP1 || !symmetryP2) return; 

            const P_mirror = getMirrorPoint(x, y);
            const P_mirror_last = getMirrorPoint(lastX, lastY);

            // ã€ä¿®æ­£ä¸€ï¼šè¨˜éŒ„ç·šæ®µåˆ°æ­·å²ç´€éŒ„ã€‘
            drawingHistory.push({ x1: lastX, y1: lastY, x2: x, y2: y }); // åŸå§‹ç·šæ®µ
            drawingHistory.push({ x1: P_mirror_last.x, y1: P_mirror_last.y, x2: P_mirror.x, y2: P_mirror.y }); // é¡åƒç·šæ®µ

            // é›–ç„¶ç´€éŒ„äº†ï¼Œä½†ç‚ºäº†å¯¦æ™‚éŸ¿æ‡‰ï¼Œæˆ‘å€‘ä»éœ€ç«‹å³ç•«å‡ºä¾†
            
            // ç¹ªè£½å‰é‡è¨­ç¹ªåœ–æ¨£å¼
            ctx.strokeStyle = USER_STROKE_COLOR;
            ctx.lineWidth = 5;
            ctx.globalAlpha = 1.0;
            ctx.setLineDash([]); 

            // 1. ç¹ªè£½åŸå§‹ç·šæ¢
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();

            // 2. ç¹ªè£½å°ç¨±ç·šæ¢
            ctx.beginPath();
            ctx.moveTo(P_mirror_last.x, P_mirror_last.y);
            ctx.lineTo(P_mirror.x, P_mirror.y);
            ctx.stroke();

            [lastX, lastY] = [x, y];
        }
        
        function startDrawing(x, y) {
            if (!isDrawingMode || !symmetryP1 || !symmetryP2) return; 
            isDrawing = true;
            [lastX, lastY] = [x, y];
        }
        
        function stopDrawing() { isDrawing = false; }
        
        function getCanvasCoords(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        // --- ã€ä¿®æ”¹å‡½æ•¸ã€‘è¨­å®šå°ç¨±è»¸é‚è¼¯ (åŠ å…¥å³æ™‚ç¹ªè£½æ¨™è¨˜) ---
        function setSymmetryAxisPoint(x, y) {
            if (isSettingAxisP1) {
                // è¨­å®š P1
                symmetryP1 = { x, y };
                isSettingAxisP1 = false;
                isSettingAxisP2 = true;
                
                // ã€æ–°åŠŸèƒ½ã€‘å³æ™‚ç¹ªè£½ P1 æ¨™è¨˜ (ç²‰è‰²)
                drawAxisPointMarker(x, y, '#ff33cc'); 
                
                statusText.textContent = 'æ­¥é©Ÿ 2/2ï¼šè«‹é»æ“Šç•«å¸ƒä¸Šçš„ **ç¬¬äºŒå€‹é»** ä¾†å®šç¾©è»¸ç·šæ–¹å‘ã€‚';
                setAxisButton.textContent = 'ğŸ–±ï¸ è¨­å®šé» 2...';
            } else if (isSettingAxisP2) {
                // è¨­å®š P2
                symmetryP2 = { x, y };
                isSettingAxisP2 = false;
                
                angle = Math.atan2(symmetryP2.y - symmetryP1.y, symmetryP2.x - symmetryP1.x);

                canvas.style.cursor = 'default';
                setAxisButton.textContent = `âœ… AXIS ONLINE`;
                setAxisButton.style.backgroundColor = '#17a2b8';
                statusText.textContent = 'è»¸ç·šå·²é–å®šï¼è«‹é»æ“Šã€Œé–‹å§‹ç¹ªè£½ã€æŒ‰éˆ•ã€‚';
                
                resizeCanvas(); // å•Ÿå‹•é–ƒçˆå‹•ç•« (æœƒæ¸…é™¤ç•«å¸ƒä¸¦é‡ç¹ªè»¸ç·šå’ŒP1/P2)
            }
        }

        // --- æŒ‰éˆ•äº‹ä»¶ (æ¸…é™¤æŒ‰éˆ•éœ€æ¸…é™¤æ­·å²ç´€éŒ„) ---
        setAxisButton.addEventListener('click', () => {
            // ... (è¨­å®šè»¸ç·šé‚è¼¯ä¸è®Š) ...
            isSettingAxisP1 = true;
            isSettingAxisP2 = false;
            isDrawingMode = false;
            isDrawing = false;
            
            toggleButton.textContent = 'ğŸ–Œï¸ é»æ­¤é–‹å§‹ç¹ªè£½';
            toggleButton.style.backgroundColor = '#28a74520';
            
            canvas.style.cursor = 'crosshair';
            setAxisButton.textContent = 'ğŸ–±ï¸ è«‹é»æ“Šç•«å¸ƒä¸Šçš„ **ç¬¬ä¸€å€‹é»**...';
            setAxisButton.style.backgroundColor = '#fd7e14';
            stopFlickerAnimation(); 
            // æ¸…ç©ºç•«å¸ƒä»¥é–‹å§‹æ–°çš„è¨­å®š
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            redrawUserStrokes(); // ä¿ç•™ç”¨æˆ¶ç¹ªåœ–
            statusText.textContent = 'æ­¥é©Ÿ 1/2ï¼šè«‹åœ¨ç•«å¸ƒä¸Šé»æ“Šæˆ–è§¸ç¢°ç¬¬ä¸€å€‹é»ã€‚';
        });

        toggleButton.addEventListener('click', () => {
            // ... (åˆ‡æ›ç¹ªè£½æ¨¡å¼é‚è¼¯ä¸è®Š) ...
            if (!symmetryP1 || !symmetryP2) {
                alert('ERROR: è«‹å…ˆé»æ“Šã€Œè¨­å®šå°ç¨±è»¸ã€æŒ‰éˆ•ä¾†å®šç¾©é¡åƒè»¸ï¼');
                return;
            }
            isDrawingMode = !isDrawingMode;
            if (isDrawingMode) {
                isSettingAxisP1 = false; 
                isSettingAxisP2 = false;
                
                toggleButton.textContent = 'â¸ æš«åœç¹ªè£½';
                toggleButton.style.backgroundColor = '#dc3545';
                canvas.style.cursor = 'crosshair'; 
                statusText.textContent = 'DRAWING MODE: ACTIVATED';
            } else {
                toggleButton.textContent = 'ğŸ–Œï¸ é»æ­¤é–‹å§‹ç¹ªè£½';
                toggleButton.style.backgroundColor = '#28a74520';
                canvas.style.cursor = 'default';
                isDrawing = false; 
                statusText.textContent = 'DRAWING MODE: PAUSED';
            }
        });

        clearButton.addEventListener('click', () => {
            isDrawingMode = false;
            isSettingAxisP1 = false;
            isSettingAxisP2 = false;
            isDrawing = false;
            symmetryP1 = null; 
            symmetryP2 = null; 
            
            drawingHistory = []; // ã€ä¿®æ­£ä¸€ï¼šæ¸…é™¤æ­·å²ç´€éŒ„ã€‘
            
            stopFlickerAnimation(); 
            resizeCanvas(); 
            
            // é‡è¨­æŒ‰éˆ•ç‹€æ…‹
            toggleButton.textContent = 'ğŸ–Œï¸ é»æ­¤é–‹å§‹ç¹ªè£½';
            toggleButton.style.backgroundColor = '#28a74520';
            setAxisButton.textContent = 'ğŸ“Œ è¨­å®šå°ç¨±è»¸ (1/2)';
            setAxisButton.style.backgroundColor = '#ffc10720';
            canvas.style.cursor = 'default';
            statusText.textContent = 'ç•«å¸ƒå·²æ¸…é™¤ï¼è«‹é‡æ–°è¨­å®šå°ç¨±è»¸ã€‚';
        });
        
        // --- é»æ“Š/è§¸æ§è™•ç† (ä¿æŒä¸è®Š) ---
        function handleInteraction(clientX, clientY) {
            const { x, y } = getCanvasCoords(clientX, clientY);
            if (isSettingAxisP1 || isSettingAxisP2) {
                setSymmetryAxisPoint(x, y);
            } else if (isDrawingMode) {
                startDrawing(x, y);
            }
        }

        canvas.addEventListener('mousedown', (e) => handleInteraction(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            handleInteraction(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });
        
        canvas.addEventListener('mousemove', (e) => {
            const { x, y } = getCanvasCoords(e.clientX, e.clientY);
            symmetricalDraw(x, y);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); 
            const touch = e.touches[0];
            const { x, y } = getCanvasCoords(touch.clientX, touch.clientY);
            symmetricalDraw(x, y);
        }, { passive: false });

        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);
    </script>

</body>
</html>