<!DOCTYPE html>
<html lang="zh-TW"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç·šå°ç¨±æ•™å­¸å·¥å…·ç®± v2.2</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --sidebar-bg: #252525;
            --canvas-bg: #000;
            --accent-color: #00ffc4;
            --text-color: #e0e0e0;
            /* æŒ‰éˆ•è‰²ç³» */
            --btn-primary: linear-gradient(135deg, #667eea, #764ba2);
            --btn-action: linear-gradient(135deg, #2af598, #009efd);
            --btn-danger: linear-gradient(135deg, #ff416c, #ff4b2b);
            --btn-cheat: linear-gradient(135deg, #f093fb, #f5576c);
            --btn-neon: linear-gradient(135deg, #89f7fe, #66a6ff);
            --btn-gold: linear-gradient(135deg, #f09819, #edde5d);
            --btn-race: linear-gradient(135deg, #ff9966, #ff5e62);
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            background-color: var(--bg-color); 
            color: var(--text-color); 
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation; 
            overflow: hidden;
            height: 100dvh; 
            display: flex;
            flex-direction: column;
        }

        /* --- Header --- */
        header {
            background: var(--panel-bg);
            padding: 0 10px;
            height: 40px;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 100;
            flex-shrink: 0;
        }
        h1 { margin: 0; font-size: 1.1rem; color: var(--accent-color); letter-spacing: 1px; }

        /* --- Status Bar (Moved Out of Canvas) --- */
        #status-bar-container {
            background: #2a2a2a;
            width: 100%;
            padding: 8px 10px;
            text-align: center;
            border-bottom: 1px solid #444;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 95;
            flex-shrink: 0;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #status-msg {
            font-size: 1rem;
            color: var(--accent-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- Main Layout --- */
        #layout-body {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* --- Left Sidebar (Modes) --- */
        #sidebar-left {
            width: 80px;
            background: var(--sidebar-bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 5px;
            gap: 10px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
            z-index: 90;
            overflow-y: auto;
            flex-shrink: 0;
            -webkit-overflow-scrolling: touch;
        }

        .mode-btn {
            width: 100%;
            background: #333;
            border: 1px solid #444;
            color: #aaa;
            padding: 10px 2px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            touch-action: manipulation; 
        }
        .mode-btn i { font-size: 1.4rem; font-style: normal; margin-bottom: 2px; }
        .mode-btn.active {
            border-color: var(--accent-color);
            color: #fff;
            background: rgba(0, 255, 196, 0.1);
            box-shadow: 0 0 8px rgba(0, 255, 196, 0.2);
        }
        
        .mode-btn.race-mode.active {
             border-color: #ff5e62;
             background: rgba(255, 94, 98, 0.1);
             box-shadow: 0 0 8px rgba(255, 94, 98, 0.3);
        }

        /* --- Center (Canvas) --- */
        #canvas-wrapper {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 30px 30px;
            overflow: hidden;
            padding: 10px;
            touch-action: none; 
        }

        canvas {
            background-color: var(--canvas-bg);
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
            touch-action: none;
            display: block;
        }

        /* --- Right Sidebar (Tools) --- */
        #sidebar-right {
            width: 140px;
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
            padding: 10px;
            gap: 8px;
            box-shadow: -2px 0 10px rgba(0,0,0,0.3);
            z-index: 90;
            overflow-y: auto;
            flex-shrink: 0;
            border-left: 1px solid #333;
            -webkit-overflow-scrolling: touch;
        }

        button.tool-btn {
            width: 100%;
            padding: 10px 12px;
            font-size: 0.9rem;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            background: #444;
            display: flex; align-items: center; justify-content: center; gap: 6px;
            transition: transform 0.1s, opacity 0.2s;
            white-space: nowrap;
            min-height: 40px;
            touch-action: manipulation; 
        }
        button.tool-btn:active { transform: scale(0.95); opacity: 0.8; }
        
        /* Button Colors */
        .btn-primary { background: var(--btn-primary) !important; }
        .btn-action { background: var(--btn-action) !important; color: #00332c !important; }
        .btn-danger { background: var(--btn-danger) !important; }
        .btn-cheat { background: var(--btn-cheat) !important; color: #5e0000 !important; }
        .btn-neon { background: var(--btn-neon) !important; color: #000 !important; }
        .btn-gold { background: var(--btn-gold) !important; color: #330 !important; }
        .btn-race { background: var(--btn-race) !important; color: #fff !important; }

        .cheat-active {
            background: #ff416c !important;
            box-shadow: 0 0 15px #ff416c, inset 0 0 5px #fff;
            border: 2px solid #fff !important;
            animation: pulse-cheat 1.5s infinite alternate;
        }
        @keyframes pulse-cheat { from { box-shadow: 0 0 10px #ff416c; } to { box-shadow: 0 0 25px #ff416c; } }

        .answer-active {
            background: var(--btn-gold) !important;
            box-shadow: 0 0 15px #ffd700;
            border: 1px solid #fff !important;
            animation: pulse-gold 1s infinite alternate;
        }
        @keyframes pulse-gold { from { box-shadow: 0 0 5px #ffd700; transform: scale(1); } to { box-shadow: 0 0 20px #ffd700; transform: scale(1.02); } }

        /* --- Overlay --- */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            justify-content: center; align-items: center;
            z-index: 200;
            backdrop-filter: blur(5px);
        }
        #overlay.show { display: flex; animation: fadeIn 0.3s; }
        
        .score-card {
            background: #222; border: 2px solid #ffd700;
            padding: 30px; border-radius: 15px;
            text-align: center; min-width: 300px;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* Race Timer Styling */
        .race-timer {
            position: absolute; top: 10px; right: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1.5rem; color: #ff5e62;
            font-weight: bold;
            background: rgba(0,0,0,0.6);
            padding: 5px 10px; border-radius: 5px;
            border: 1px solid #ff5e62;
            z-index: 15;
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #222; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }

    </style>
</head>
<body>

    <header>
        <h1>ç·šå°ç¨±æ•™å­¸å·¥å…·ç®± ğŸš€</h1>
    </header>

    <div id="status-bar-container">
        <div id="status-msg">æ­¥é©Ÿ 1ï¼šè«‹é»æ“Šã€ŒğŸ“Œ è¨­å®šè»¸ç·šã€</div>
    </div>

    <div id="layout-body">
        <aside id="sidebar-left">
            <button class="mode-btn active" id="btn-free" onclick="App.switchMode('FREE')">
                <i>ğŸ¨</i> è‡ªç”±ç¹ªåœ–
            </button>
            <button class="mode-btn" id="btn-grid" onclick="App.switchMode('GRID')">
                <i>ğŸ§©</i> æ–¹æ ¼å¡«è‰²
            </button>
            <button class="mode-btn" id="btn-dots" onclick="App.switchMode('DOTS')">
                <i>ğŸ“</i> å¹¾ä½•é€£ç·š
            </button>
            <button class="mode-btn" id="btn-mandala" onclick="App.switchMode('MANDALA')">
                <i>ğŸŒ€</i> è¬èŠ±ç­’
            </button>
            <div style="height:1px; width:80%; background:#444; margin:5px 0;"></div>
            <button class="mode-btn race-mode" id="btn-gridrace" onclick="App.switchMode('GRID_RACE')">
                <i>ğŸ†</i> æ–¹æ ¼ç«¶é€Ÿ
            </button>
            <button class="mode-btn race-mode" id="btn-dotsrace" onclick="App.switchMode('DOTS_RACE')">
                <i>â±ï¸</i> é€£ç·šç«¶é€Ÿ
            </button>
        </aside>

        <div id="canvas-wrapper">
            <canvas id="appCanvas"></canvas>
            
            <div id="overlay">
                <div class="score-card">
                    <h2 id="score-title" style="color:#ffd700; font-size:2rem; margin:0;">100åˆ†</h2>
                    <p id="score-desc" style="color:#ccc; margin:15px 0 25px 0;">å®Œç¾å°ç¨±ï¼</p>
                    <button class="tool-btn btn-primary" style="margin:0 auto; width:100%; justify-content:center;" onclick="document.getElementById('overlay').classList.remove('show')">é—œé–‰</button>
                </div>
            </div>
        </div>

        <aside id="sidebar-right">
        </aside>
    </div>

    <script>
        /**
         * APP CORE
         */
        const App = {
            mode: null,
            canvas: document.getElementById('appCanvas'),
            ctx: document.getElementById('appCanvas').getContext('2d'),
            statusEl: document.getElementById('status-msg'),
            toolbarEl: document.getElementById('sidebar-right'),
            width: 0, height: 0, dpr: 1,
            resizeTimer: null,

            init() {
                document.addEventListener('dblclick', function(event) { event.preventDefault(); }, { passive: false });
                
                window.addEventListener('resize', () => {
                    clearTimeout(this.resizeTimer);
                    this.resizeTimer = setTimeout(() => this.resizeCanvas(), 100);
                });
                
                const handler = (type, e) => {
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
                    
                    const isCanvasEvent = (e.target === this.canvas);
                    if (isCanvasEvent && e.type !== 'touchend') e.preventDefault(); 

                    const rect = this.canvas.getBoundingClientRect();
                    let cx, cy;
                    if (e.touches && e.touches.length) { cx = e.touches[0].clientX; cy = e.touches[0].clientY; }
                    else if (e.changedTouches && e.changedTouches.length) { cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY; }
                    else { cx = e.clientX; cy = e.clientY; }
                    
                    const pos = { x: cx - rect.left, y: cy - rect.top };
                    const target = this.getCurrentModeObj();
                    if (target) {
                        if (type === 'start' && target.onStart) target.onStart(pos);
                        if (type === 'move' && target.onMove) target.onMove(pos);
                        if (type === 'end' && target.onEnd) target.onEnd();
                    }
                };

                this.canvas.addEventListener('mousedown', e => handler('start', e));
                this.canvas.addEventListener('mousemove', e => handler('move', e));
                this.canvas.addEventListener('touchstart', e => handler('start', e), {passive: false});
                this.canvas.addEventListener('touchmove', e => handler('move', e), {passive: false});
                window.addEventListener('mouseup', e => handler('end', e));
                window.addEventListener('touchend', e => handler('end', e));

                this.resizeCanvas();
                this.switchMode('FREE');
                this.loop();
            },

            getCurrentModeObj() {
                if (this.mode === 'FREE') return FreeMode;
                if (this.mode === 'GRID') return GridMode;
                if (this.mode === 'DOTS') return DotsMode;
                if (this.mode === 'MANDALA') return MandalaMode;
                if (this.mode === 'GRID_RACE') return GridRaceMode;
                if (this.mode === 'DOTS_RACE') return DotsRaceMode;
                return null;
            },

            switchMode(newMode) {
                const oldMode = this.getCurrentModeObj();
                if(oldMode && oldMode.cleanup) oldMode.cleanup();

                this.mode = newMode;
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                document.getElementById(`btn-${newMode.toLowerCase().replace('_','')}`).classList.add('active');
                document.getElementById('overlay').classList.remove('show');

                this.resizeCanvas(); 
                const newObj = this.getCurrentModeObj();
                if (newObj) {
                    newObj.cheatMode = false;
                    if (newObj.init) newObj.init();
                }
                this.renderToolbar(); 
            },

            resizeCanvas() {
                const wrapper = document.getElementById('canvas-wrapper');
                const rect = wrapper.getBoundingClientRect();
                const w = rect.width - 20; 
                const h = rect.height - 20;
                
                if (w <= 0 || h <= 0) return; 

                this.dpr = window.devicePixelRatio || 1;

                let finalW = w, finalH = h;
                if (this.mode !== 'FREE') {
                    const size = Math.min(w, h);
                    finalW = size; finalH = size;
                }
                
                if (this.canvas.width !== finalW * this.dpr || this.canvas.height !== finalH * this.dpr) {
                    this.canvas.style.width = `${finalW}px`;
                    this.canvas.style.height = `${finalH}px`;
                    this.canvas.width = finalW * this.dpr;
                    this.canvas.height = finalH * this.dpr;
                    this.width = finalW; this.height = finalH;
                    
                    this.ctx.resetTransform(); 
                    this.ctx.scale(this.dpr, this.dpr);
                } else {
                    this.ctx.resetTransform();
                    this.ctx.scale(this.dpr, this.dpr);
                }

                const obj = this.getCurrentModeObj();
                if (obj && obj.draw) {
                    requestAnimationFrame(() => obj.draw());
                }
            },

            renderToolbar() {
                const obj = this.getCurrentModeObj();
                this.toolbarEl.innerHTML = (obj && obj.getToolbarHTML) ? obj.getToolbarHTML() : '';
            },

            loop() {
                requestAnimationFrame(() => this.loop());
                const obj = this.getCurrentModeObj();
                if (this.mode === 'MANDALA' || this.mode === 'FREE' || (obj && obj.needsLoop)) {
                    if (obj && obj.draw) obj.draw();
                }
            },
            
            showScore(score, text, btnText="é—œé–‰", callback=null) {
                document.getElementById('score-title').innerText = score;
                document.getElementById('score-desc').innerHTML = text;
                const btn = document.querySelector('#overlay button');
                btn.innerText = btnText;
                btn.onclick = () => {
                    document.getElementById('overlay').classList.remove('show');
                    if(callback) callback();
                };
                document.getElementById('overlay').classList.add('show');
            }
        };

        // --- UTILS ---
        const getLineUniqueKey = (r1, c1, r2, c2) => {
            let p1 = {r: r1, c: c1}, p2 = {r: r2, c: c2};
            if (p1.r > p2.r || (p1.r === p2.r && p1.c > p2.c)) { [p1, p2] = [p2, p1]; }
            return `${p1.r},${p1.c}-${p2.r},${p2.c}`;
        };

        const formatTime = (ms) => {
            const min = Math.floor(ms / 60000);
            const sec = Math.floor((ms % 60000) / 1000);
            const centi = Math.floor((ms % 1000) / 10);
            return `${min}åˆ†${sec.toString().padStart(2,'0')}ç§’.${centi.toString().padStart(2,'0')}`;
        };

        /**
         * =========================================
         * MODE 1: FREE DRAW
         * =========================================
         */
        const FreeMode = {
            state: 'IDLE', p1: null, p2: null, strokes: [], currentStroke: [], 
            isDrawing: false, drawColor: 'RED', showAnswer: false, cheatMode: false, flicker: 0,

            init() { this.reset(); }, cleanup() { this.cheatMode = false; },
            reset() {
                this.strokes = []; this.p1 = null; this.p2 = null; this.currentStroke = [];
                this.showAnswer = false; this.state = 'IDLE';
                if (this.cheatMode) this.startCheatFlow();
                else { App.statusEl.innerText = "æ­¥é©Ÿ 1ï¼šè«‹é»æ“Šã€ŒğŸ“Œ è¨­å®šè»¸ç·šã€"; App.renderToolbar(); this.draw(); }
            },
            toggleCheat() { this.cheatMode = !this.cheatMode; this.reset(); },
            startCheatFlow() {
                this.strokes = []; this.p1 = null; this.p2 = null; this.state = 'SET_P1'; this.drawColor = 'RED'; 
                App.statusEl.innerText = "ã€ä½œå¼Šæ¨¡å¼ã€‘è¨­å®šè»¸ç·šèµ·é»"; App.renderToolbar(); this.draw();
            },
            getToolbarHTML() {
                const cheatBtn = this.cheatMode ? 
                    `<button class="tool-btn btn-cheat cheat-active" onclick="FreeMode.toggleCheat()">âš¡ çµæŸä½œå¼Š</button>` :
                    `<button class="tool-btn btn-cheat" onclick="FreeMode.toggleCheat()">âš¡ ä½œå¼Šæ¨¡å¼</button>`;

                if (this.cheatMode) return `${cheatBtn} <div style="color:#ff9a9e; font-weight:bold; margin:5px 0; text-align:center; font-size:0.8rem;">ä½œå¼Šé–‹å•Ÿ<br>å³æ™‚é¡åƒ</div> <button class="tool-btn btn-danger" onclick="FreeMode.reset()">ğŸ—‘ï¸ æ¸…ç©ºé‡ç•«</button>`;
                return `<button class="tool-btn" style="background:#555" onclick="FreeMode.setAxis()">ğŸ“Œ è¨­å®šè»¸ç·š</button><button class="tool-btn btn-primary" onclick="FreeMode.setColor('RED')">ğŸ–ï¸ é¡Œç›®(ç´…)</button><button class="tool-btn btn-action" onclick="FreeMode.setColor('BLUE')">ğŸ–Šï¸ ä½œç­”(è—)</button>${cheatBtn}<button class="tool-btn" onclick="FreeMode.toggleAnswer()">ğŸ‘€ é¡¯ç¤ºç­”æ¡ˆ</button><button class="tool-btn btn-danger" onclick="FreeMode.reset()">ğŸ—‘ï¸ é‡è¨­</button>`;
            },
            setAxis() { this.state = 'SET_P1'; this.p1 = null; this.p2 = null; this.strokes = []; App.statusEl.innerText = "è¨­å®šè»¸ç·šèµ·é»"; this.draw(); },
            setColor(c) { if(!this.p1 || !this.p2) return alert("è«‹å…ˆè¨­å®šä¸¦ç•«å‡ºè»¸ç·š"); this.drawColor = c; this.state = 'DRAWING'; App.statusEl.innerText = c==='RED' ? "ç¹ªè£½é¡Œç›®" : "ç¹ªè£½ç­”æ¡ˆ"; },
            toggleAnswer() { if(!this.p1) return; this.showAnswer = !this.showAnswer; this.draw(); },
            getMirror(x, y) {
                if (!this.p1 || !this.p2) return {x, y};
                const dx = this.p2.x - this.p1.x, dy = this.p2.y - this.p1.y;
                const det = dx*dx + dy*dy; if(det===0) return {x,y};
                const a = (dx*dx - dy*dy)/det, b = 2*dx*dy/det;
                return { x: a*(x-this.p1.x) + b*(y-this.p1.y) + this.p1.x, y: b*(x-this.p1.x) - a*(y-this.p1.y) + this.p1.y };
            },
            onStart(pos) {
                if (this.state === 'SET_P1') { this.p1 = pos; this.state = 'SET_P2'; App.statusEl.innerText = "è¨­å®šè»¸ç·šçµ‚é»"; }
                else if (this.state === 'SET_P2') { this.p2 = pos; this.state = 'DRAWING'; App.statusEl.innerText = this.cheatMode ? "ã€ä½œå¼Šæ¨¡å¼ã€‘é–‹å§‹ç¹ªåœ–ï¼" : "è»¸ç·šå®Œæˆï¼Œè«‹é¸æ“‡ç•«ç­†é–‹å§‹"; }
                else if (this.state === 'DRAWING' || this.state === 'IDLE') { if (!this.p1 || !this.p2) return; this.isDrawing = true; this.currentStroke = [pos]; }
            },
            onMove(pos) { if (this.isDrawing) this.currentStroke.push(pos); },
            onEnd() {
                if (this.isDrawing) {
                    this.isDrawing = false; const color = this.drawColor === 'RED' ? '#ff33cc' : '#33ccff';
                    this.strokes.push({ points: this.currentStroke, color });
                    if (this.cheatMode && this.p1 && this.p2) { const mirrorPoints = this.currentStroke.map(p => this.getMirror(p.x, p.y)); this.strokes.push({ points: mirrorPoints, color }); }
                    this.currentStroke = [];
                }
            },
            draw() {
                const ctx = App.ctx; ctx.clearRect(0, 0, App.width, App.height);
                ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                this.strokes.forEach(s => {
                    if(s.points.length<2) return; ctx.strokeStyle = s.color; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.moveTo(s.points[0].x, s.points[0].y); for(let i=1; i<s.points.length; i++) ctx.lineTo(s.points[i].x, s.points[i].y); ctx.stroke();
                });
                if (this.currentStroke.length > 0) {
                    ctx.strokeStyle = this.drawColor === 'RED' ? '#ff33cc' : '#33ccff'; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.moveTo(this.currentStroke[0].x, this.currentStroke[0].y); for(let i=1; i<this.currentStroke.length; i++) ctx.lineTo(this.currentStroke[i].x, this.currentStroke[i].y); ctx.stroke();
                    if(this.cheatMode && this.p1 && this.p2) {
                        ctx.beginPath(); const start = this.getMirror(this.currentStroke[0].x, this.currentStroke[0].y); ctx.moveTo(start.x, start.y);
                        for(let i=1; i<this.currentStroke.length; i++) { const m = this.getMirror(this.currentStroke[i].x, this.currentStroke[i].y); ctx.lineTo(m.x, m.y); } ctx.stroke();
                    }
                }
                if (this.showAnswer && this.p1 && this.p2) {
                    ctx.strokeStyle = 'rgba(255,215,0,0.5)'; ctx.lineWidth = 6;
                    this.strokes.forEach(s => {
                        if(s.color === '#ff33cc') {
                            ctx.beginPath(); const p0 = this.getMirror(s.points[0].x, s.points[0].y); ctx.moveTo(p0.x, p0.y);
                            for(let i=1; i<s.points.length; i++) { const p = this.getMirror(s.points[i].x, s.points[i].y); ctx.lineTo(p.x, p.y); } ctx.stroke();
                        }
                    });
                }
                if (this.p1) {
                    this.flicker++; ctx.strokeStyle = '#00ffc4'; ctx.lineWidth = 3; ctx.shadowColor = '#00ffc4'; ctx.shadowBlur = (this.flicker%60 < 30) ? 15 : 5;
                    ctx.beginPath(); ctx.moveTo(this.p1.x, this.p1.y); if (this.p2) ctx.lineTo(this.p2.x, this.p2.y); ctx.stroke(); ctx.shadowBlur = 0;
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.p1.x, this.p1.y, 5, 0, Math.PI*2); ctx.fill(); if(this.p2) { ctx.beginPath(); ctx.arc(this.p2.x, this.p2.y, 5, 0, Math.PI*2); ctx.fill(); }
                }
            }
        };

        /**
         * =========================================
         * MODE 2: GRID
         * =========================================
         */
        const GridMode = {
            size: 12, grid: [], axis: {type:'V', pos:6}, modeState: 'PLAY', cheatMode: false, showAnswer: false, needsLoop: false,
            init() { this.reset(); }, cleanup() { this.cheatMode = false; }, emptyGrid() { return Array.from({length:this.size}, ()=>Array(this.size).fill(0)); },

            reset() {
                this.grid = this.emptyGrid(); this.showAnswer = false; this.axis = {type:'V', pos:6};
                if (this.cheatMode) { this.modeState = 'CHEAT_SETUP'; App.statusEl.innerText = "ã€ä½œå¼Šæ¨¡å¼ã€‘æ­¥é©Ÿ 1ï¼šè¨­å®šè»¸ç·š"; } 
                else { this.modeState = 'PLAY'; App.statusEl.innerText = "è«‹æŒ‰ã€Œéš¨æ©Ÿå‡ºé¡Œã€æˆ–ã€Œè‡ªè¡Œå‡ºé¡Œã€"; }
                App.renderToolbar(); this.draw();
            },
            toggleCheat() { this.cheatMode = !this.cheatMode; this.reset(); },
            startCheatPlay() { this.modeState = 'CHEAT_PLAY'; App.statusEl.innerText = "ã€ä½œå¼Šæ¨¡å¼ã€‘é»æ“Šä»»æ„æ ¼å­ï¼Œå°ç¨±å´åŒæ­¥"; App.renderToolbar(); },

            getToolbarHTML() {
                const cheatBtn = this.cheatMode ? `<button class="tool-btn btn-cheat cheat-active" onclick="GridMode.toggleCheat()">âš¡ çµæŸä½œå¼Š</button>` : `<button class="tool-btn btn-cheat" onclick="GridMode.toggleCheat()">âš¡ ä½œå¼Šæ¨¡å¼</button>`;
                if (this.cheatMode && this.modeState === 'CHEAT_SETUP') return `${cheatBtn} <button class="tool-btn" onclick="GridMode.toggleAxis()">ğŸ”„ è½‰è»¸</button> <button class="tool-btn" onclick="GridMode.moveAxis()">â†”ï¸ ç§»è»¸</button> <button class="tool-btn btn-action" onclick="GridMode.startCheatPlay()">ğŸš€ é–‹å§‹ä½œå¼Š</button>`;
                if (this.cheatMode && this.modeState === 'CHEAT_PLAY') return `${cheatBtn} <div style="color:#f093fb; margin:5px 0; text-align:center; font-size:0.8rem;">é»æ“Šä»»æ„è™•<br>å³æ™‚åŒæ­¥</div> <button class="tool-btn btn-danger" onclick="GridMode.reset()">ğŸ—‘ï¸ æ¸…ç©ºé‡ä¾†</button>`;
                if (this.modeState === 'DESIGN') return `<div style="color:#ff9a9e; font-weight:bold; margin-bottom:10px; text-align:center;">âœï¸ è¨­è¨ˆé¡Œç›®ä¸­</div> <button class="tool-btn" onclick="GridMode.toggleAxis()">ğŸ”„ è½‰è»¸</button> <button class="tool-btn" onclick="GridMode.moveAxis()">â†”ï¸ ç§»è»¸</button> <button class="tool-btn btn-action" onclick="GridMode.finishDesign()">ğŸš€ é–‹å§‹æ¸¬é©—</button>`;
                return `<button class="tool-btn btn-primary" onclick="GridMode.randomLevel()">ğŸ² éš¨æ©Ÿå‡ºé¡Œ</button><button class="tool-btn" style="background:linear-gradient(135deg, #ff9a9e, #fecfef); color:#330;" onclick="GridMode.startDesign()">âœï¸ è‡ªè¡Œå‡ºé¡Œ</button>${cheatBtn}<button class="tool-btn" onclick="GridMode.toggleAnswer()">ğŸ‘€ ç­”æ¡ˆ</button><button class="tool-btn btn-action" onclick="GridMode.check()">âœ… è©•åˆ†</button><button class="tool-btn btn-danger" onclick="GridMode.reset()">ğŸ—‘ï¸ é‡è¨­</button>`;
            },
            randomLevel() {
                this.grid = this.emptyGrid(); this.modeState = 'PLAY'; this.showAnswer = false;
                this.axis.type = Math.random()>0.5?'V':'H'; this.axis.pos = 6 + (Math.floor(Math.random()*5)-2);
                let count=0; while(count<10) { let r=Math.floor(Math.random()*12), c=Math.floor(Math.random()*12); if(this.isQ(r,c) && this.getMirror(r,c) && this.grid[r][c]===0) { this.grid[r][c]=1; count++; } }
                App.statusEl.innerText = "å¡«å…¥è—è‰²å°ç¨±æ–¹å¡Š"; App.renderToolbar(); this.draw();
            },
            startDesign() { this.grid = this.emptyGrid(); this.modeState = 'DESIGN'; this.axis = {type:'V', pos:6}; App.statusEl.innerText = "è«‹ç•«ç´…è‰²æ–¹å¡Šå‡ºé¡Œï¼Œå¯èª¿æ•´è»¸ç·š"; App.renderToolbar(); this.draw(); },
            finishDesign() { if(!this.grid.flat().includes(1)) return alert("è«‹è‡³å°‘ç•«ä¸€æ ¼"); this.modeState = 'PLAY'; App.statusEl.innerText = "é¡Œç›®è¨­å®šå®Œæˆï¼Œè«‹ä½œç­”"; App.renderToolbar(); this.draw(); },
            toggleAxis() { this.axis.type = this.axis.type==='V'?'H':'V'; this.draw(); },
            moveAxis() { this.axis.pos++; if(this.axis.pos>8) this.axis.pos=4; this.draw(); },
            toggleAnswer() { this.showAnswer = !this.showAnswer; this.draw(); },
            isQ(r,c) { return this.axis.type==='V' ? c < this.axis.pos : r < this.axis.pos; },
            getMirror(r,c) { let mr, mc; if(this.axis.type==='V') { mc=(this.axis.pos*2-1)-c; mr=r; } else { mc=c; mr=(this.axis.pos*2-1)-r; } if(mc<0||mc>=12||mr<0||mr>=12) return null; return {r:mr, c:mc}; },

            onStart(pos) {
                if (this.modeState === 'REVIEW') return; 
                const cs = App.width / 12; const c = Math.floor(pos.x/cs), r = Math.floor(pos.y/cs); if(c<0||c>=12||r<0||r>=12) return;
                if (this.modeState === 'DESIGN') { if (this.isQ(r,c)) this.grid[r][c] = this.grid[r][c]===1 ? 0 : 1; }
                else if (this.modeState === 'CHEAT_SETUP') { return; }
                else if (this.modeState === 'CHEAT_PLAY') { const val = this.grid[r][c]===2 ? 0 : 2; this.grid[r][c] = val; const m = this.getMirror(r,c); if(m) this.grid[m.r][m.c] = val; }
                else if (this.modeState === 'PLAY') { if (!this.isQ(r,c)) this.grid[r][c] = (this.grid[r][c]===2) ? 0 : 2; }
                this.draw();
            },
            check() {
                this.modeState = 'REVIEW'; let correct=0, wrong=0, total=0;
                for(let r=0; r<12; r++) for(let c=0; c<12; c++) {
                    if(this.grid[r][c]===1) { const m = this.getMirror(r,c); if(m) { total++; if(this.grid[m.r][m.c]===2) correct++; } }
                    if(this.grid[r][c]===2) { const m = this.getMirror(r,c); if(!m || this.grid[m.r][m.c]!==1) wrong++; }
                }
                let score = total===0 ? 0 : Math.max(0, Math.round(((correct-wrong)/total)*100)); App.showScore(score+"åˆ†", `ç­”å° ${correct} æ ¼ï¼ŒéŒ¯ ${wrong} æ ¼`); this.draw();
            },
            draw() {
                const ctx = App.ctx, w=App.width, h=App.height, cs=w/12; ctx.clearRect(0,0,w,h);
                ctx.beginPath(); ctx.strokeStyle='#333'; ctx.lineWidth=1; 
                for(let i=0; i<=12; i++) { ctx.moveTo(0,i*cs); ctx.lineTo(w,i*cs); ctx.moveTo(i*cs,0); ctx.lineTo(i*cs,h); } ctx.stroke();
                for(let r=0; r<12; r++) for(let c=0; c<12; c++) {
                    const v = this.grid[r][c];
                    if(v===1) { ctx.fillStyle='#ff33cc'; ctx.fillRect(c*cs+1,r*cs+1,cs-2,cs-2); }
                    if(v===2) { ctx.fillStyle='#33ccff'; ctx.fillRect(c*cs+1,r*cs+1,cs-2,cs-2); }
                    if(this.showAnswer && v===0 && !this.isQ(r,c)) { const m = this.getMirror(r,c); if(m && this.grid[m.r][m.c]===1) { ctx.fillStyle='rgba(255,215,0,0.4)'; ctx.fillRect(c*cs+1,r*cs+1,cs-2,cs-2); } }
                    if(this.modeState==='REVIEW' && v===2) { const m = this.getMirror(r,c); if(m && this.grid[m.r][m.c]===1) { ctx.strokeStyle='#ffd700'; ctx.lineWidth=3; ctx.strokeRect(c*cs+3,r*cs+3,cs-6,cs-6); } else { ctx.strokeStyle='#ff4444'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(c*cs+4,r*cs+4); ctx.lineTo((c+1)*cs-4,(r+1)*cs-4); ctx.stroke(); ctx.beginPath(); ctx.moveTo((c+1)*cs-4,r*cs+4); ctx.lineTo(c*cs+4,(r+1)*cs-4); ctx.stroke(); } }
                }
                ctx.strokeStyle='#00ffc4'; ctx.lineWidth=4; ctx.shadowColor='#00ffc4'; ctx.shadowBlur=10; ctx.beginPath(); if(this.axis.type==='V') { ctx.moveTo(this.axis.pos*cs,0); ctx.lineTo(this.axis.pos*cs,h); } else { ctx.moveTo(0,this.axis.pos*cs); ctx.lineTo(w,this.axis.pos*cs); } ctx.stroke(); ctx.shadowBlur=0;
            }
        };

        /**
         * =========================================
         * NEW MODE 5: GRID RACE (Difficulty Increased)
         * =========================================
         */
        const GridRaceMode = {
            grid: [], axis: {type:'V', pos:6}, state: 'IDLE', // IDLE, PLAYING, FINISHED
            level: 1, maxLevels: 3, startTime: 0, needsLoop: true,
            
            init() { this.state = 'IDLE'; App.statusEl.innerText = "ç«¶è³½æ¨¡å¼ï¼šé€£çºŒå®Œæˆä¸‰é“æŒ‘æˆ°é¡Œ"; this.level=1; App.renderToolbar(); this.draw(); },
            start() { 
                this.level = 1; this.startTime = Date.now(); this.state = 'PLAYING'; 
                this.generateLevel(); 
                App.renderToolbar();
            },
            generateLevel() {
                this.grid = GridMode.emptyGrid.call(GridMode); // reuse helper
                this.axis.type = Math.random()>0.5?'V':'H'; this.axis.pos = 6 + (Math.floor(Math.random()*5)-2);
                let count=0; 
                // [FIX] Increased count from 8 to 15 for difficulty
                while(count<15) { 
                    let r=Math.floor(Math.random()*12), c=Math.floor(Math.random()*12); 
                    if(GridMode.isQ.call(this,r,c) && GridMode.getMirror.call(this,r,c) && this.grid[r][c]===0) { 
                        this.grid[r][c]=1; count++; 
                    } 
                }
                App.statusEl.innerText = `ç¬¬ ${this.level}/3 é—œï¼šå¡«æ»¿å°ç¨±åœ–å½¢ (15æ ¼)`;
            },
            check() {
                if(this.state !== 'PLAYING') return;
                let correct = true;
                // Simple validation: All '1's must have a mirror '2', All '2's must mirror '1'
                for(let r=0; r<12; r++) for(let c=0; c<12; c++) {
                    const m = GridMode.getMirror.call(this, r, c);
                    if(!m) continue;
                    // If this cell is Q(1), mirror must be A(2)
                    if(this.grid[r][c] === 1 && this.grid[m.r][m.c] !== 2) correct = false;
                    // If this cell is A(2), mirror must be Q(1)
                    if(this.grid[r][c] === 2 && this.grid[m.r][m.c] !== 1) correct = false;
                }
                
                if(correct) {
                    if(this.level >= this.maxLevels) {
                        this.finish();
                    } else {
                        this.level++;
                        this.generateLevel();
                    }
                } else {
                    App.statusEl.innerText = "ç­”æ¡ˆéŒ¯èª¤ï¼Œè«‹æª¢æŸ¥ï¼";
                    setTimeout(() => App.statusEl.innerText = `ç¬¬ ${this.level}/3 é—œï¼šå¡«æ»¿å°ç¨±åœ–å½¢`, 1000);
                }
            },
            finish() {
                this.state = 'FINISHED';
                const totalTime = Date.now() - this.startTime;
                App.showScore("æŒ‘æˆ°æˆåŠŸ", `ç¸½æ™‚é–“ï¼š${formatTime(totalTime)}`);
                App.renderToolbar();
            },
            onStart(pos) {
                if (this.state !== 'PLAYING') return; 
                const cs = App.width / 12; const c = Math.floor(pos.x/cs), r = Math.floor(pos.y/cs); 
                if(c<0||c>=12||r<0||r>=12) return;
                // Reuse logic: only click on non-question side
                if (!GridMode.isQ.call(this,r,c)) this.grid[r][c] = (this.grid[r][c]===2) ? 0 : 2;
                // Auto-check is usually annoying if mid-click, so we rely on manual check button
            },
            getToolbarHTML() {
                if(this.state === 'IDLE') return `<button class="tool-btn btn-race" onclick="GridRaceMode.start()">ğŸ é–‹å§‹æŒ‘æˆ°</button>`;
                if(this.state === 'FINISHED') return `<button class="tool-btn btn-primary" onclick="GridRaceMode.init()">ğŸ”„ é‡æ–°é–‹å§‹</button>`;
                return `<button class="tool-btn btn-action" onclick="GridRaceMode.check()">âœ… å®Œæˆ (ç¬¬ ${this.level} é—œ)</button>`;
            },
            draw() {
                // Reuse GridMode draw logic but add Timer
                GridMode.draw.call(this);
                
                const ctx = App.ctx;
                // Draw Timer overlay
                if(this.state === 'PLAYING') {
                    const elapsed = Date.now() - this.startTime;
                    ctx.save();
                    ctx.fillStyle = "rgba(0,0,0,0.6)";
                    ctx.fillRect(App.width - 220, 10, 210, 50);
                    ctx.strokeStyle = "#ff5e62";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(App.width - 220, 10, 210, 50);
                    
                    ctx.fillStyle = "#ff5e62";
                    ctx.font = "bold 30px Courier New";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(formatTime(elapsed), App.width - 115, 35);
                    ctx.restore();
                }
            }
        };

        /**
         * =========================================
         * MODE 3 & 6: DOTS (Visual Comparison Mode)
         * =========================================
         */
        const DotsMode = {
            lines: [], axis: {type:'V', pos:6}, modeState: 'PLAY', cheatMode: false, 
            showAnswer: false, drag: {active:false}, needsLoop: false,

            init() { this.reset(); }, cleanup() { this.cheatMode = false; this.needsLoop = false; },
            reset() {
                this.lines = []; this.showAnswer = false; this.needsLoop = false; this.axis = {type:'V', pos:6};
                if (this.cheatMode) { this.modeState = 'CHEAT_SETUP'; App.statusEl.innerText = "ã€ä½œå¼Šæ¨¡å¼ã€‘æ­¥é©Ÿ 1ï¼šè¨­å®šè»¸ç·š"; } else { this.modeState = 'PLAY'; App.statusEl.innerText = "è«‹é¸æ“‡å‡ºé¡Œæ–¹å¼"; }
                App.renderToolbar(); this.draw();
            },
            toggleCheat() { this.cheatMode = !this.cheatMode; this.reset(); },
            startCheatPlay() { this.modeState = 'CHEAT_PLAY'; App.statusEl.innerText = "ã€ä½œå¼Šæ¨¡å¼ã€‘é€£ç·šä»»æ„å…©é»ï¼Œå°é¢è‡ªå‹•ç”Ÿæˆ"; App.renderToolbar(); },
            
            getToolbarHTML() {
                const cheatBtn = this.cheatMode ? `<button class="tool-btn btn-cheat cheat-active" onclick="DotsMode.toggleCheat()">âš¡ çµæŸä½œå¼Š</button>` : `<button class="tool-btn btn-cheat" onclick="DotsMode.toggleCheat()">âš¡ ä½œå¼Šæ¨¡å¼</button>`;
                let answerBtnClass = "tool-btn btn-gold";
                if (this.showAnswer) answerBtnClass += " answer-active";

                if (this.cheatMode && this.modeState === 'CHEAT_SETUP') return `${cheatBtn} <button class="tool-btn" onclick="DotsMode.toggleAxis()">ğŸ”„ è½‰è»¸</button> <button class="tool-btn" onclick="DotsMode.moveAxis()">â†”ï¸ ç§»è»¸</button> <button class="tool-btn btn-action" onclick="DotsMode.startCheatPlay()">ğŸš€ é–‹å§‹ä½œå¼Š</button>`;
                if (this.cheatMode && this.modeState === 'CHEAT_PLAY') return `${cheatBtn} <div style="color:#f093fb; margin:5px 0; text-align:center; font-size:0.8rem;">ä»»æ„é€£ç·š<br>è‡ªå‹•é¡åƒ</div> <button class="tool-btn btn-danger" onclick="DotsMode.reset()">ğŸ—‘ï¸ æ¸…ç©ºé‡ä¾†</button>`;
                if (this.modeState === 'DESIGN') return `<div style="color:#ff9a9e; font-weight:bold; margin-bottom:10px; text-align:center;">âœï¸ è¨­è¨ˆä¸­</div> <button class="tool-btn" onclick="DotsMode.toggleAxis()">ğŸ”„ è½‰è»¸</button> <button class="tool-btn" onclick="DotsMode.moveAxis()">â†”ï¸ ç§»è»¸</button> <button class="tool-btn btn-action" onclick="DotsMode.finishDesign()">ğŸš€ é–‹å§‹æ¸¬é©—</button>`;
                
                return `
                    <div style="display:flex; gap:5px; width:100%;">
                        <button class="tool-btn btn-primary" style="padding:5px; font-size:0.8rem;" onclick="DotsMode.randomLevel('EASY')">ç°¡å–®</button>
                        <button class="tool-btn btn-primary" style="padding:5px; font-size:0.8rem;" onclick="DotsMode.randomLevel('MEDIUM')">ä¸­ç­‰</button>
                        <button class="tool-btn btn-primary" style="padding:5px; font-size:0.8rem;" onclick="DotsMode.randomLevel('HARD')">æŒ‘æˆ°</button>
                    </div>
                    <button class="tool-btn" style="background:linear-gradient(135deg, #ff9a9e, #fecfef); color:#330;" onclick="DotsMode.startDesign()">âœï¸ è‡ªè¡Œå‡ºé¡Œ</button>
                    ${cheatBtn}
                    <button class="${answerBtnClass}" onclick="DotsMode.toggleAnswer()">ğŸ‘€ ç­”æ¡ˆå°ç…§</button>
                    <button class="tool-btn btn-danger" onclick="DotsMode.reset()">ğŸ—‘ï¸ é‡è¨­</button>
                `;
            },
            
            randomLevel(difficulty) {
                this.lines=[]; this.modeState='PLAY'; this.showAnswer=false; this.needsLoop=false;
                this.axis.type=Math.random()>0.5?'V':'H'; this.axis.pos=6+(Math.floor(Math.random()*5)-2);
                
                let targetSegments = 4;
                if (difficulty === 'MEDIUM') targetSegments = 10;
                if (difficulty === 'HARD') targetSegments = 56; 

                const getRandomStart = () => {
                    let attempts = 0;
                    while (attempts < 100) {
                        let r = Math.floor(Math.random() * 12);
                        let c = Math.floor(Math.random() * 12);
                        if (this.isQ(r, c) && this.getMirror(r, c)) return { r, c };
                        attempts++;
                    }
                    return { r: 0, c: 0 };
                };

                let current = getRandomStart();
                let r = current.r, c = current.c;
                let segmentsCreated = 0;
                let totalAttempts = 0;

                while(segmentsCreated < targetSegments && totalAttempts < 2000) {
                    totalAttempts++;
                    const dr=Math.floor(Math.random()*3)-1, dc=Math.floor(Math.random()*3)-1; 
                    if(dr===0 && dc===0) {
                        if (totalAttempts % 10 === 0) { let next = getRandomStart(); r = next.r; c = next.c; }
                        continue;
                    }
                    const nr=r+dr, nc=c+dc; 
                    if(nr>=0 && nr<12 && nc>=0 && nc<12 && this.isQ(nr,nc) && this.getMirror(nr,nc)) { 
                        const key = getLineUniqueKey(r, c, nr, nc);
                        if (!this.lines.some(l => getLineUniqueKey(l.r1, l.c1, l.r2, l.c2) === key)) {
                            this.addLine({ r1: r, c1: c, r2: nr, c2: nc, type: 1 });
                            segmentsCreated++;
                            r = nr; c = nc; 
                        } else {
                            if (Math.random() > 0.8) { let next = getRandomStart(); r = next.r; c = next.c; }
                        }
                    } else {
                        if (Math.random() > 0.5) { let next = getRandomStart(); r = next.r; c = next.c; }
                    }
                }
                
                let msg = "é€£ç·šç•«å‡ºå°ç¨±åœ–å½¢";
                if (difficulty === 'HARD') msg = "æŒ‘æˆ°æ¨¡å¼ï¼šè«‹å®Œæˆè¤‡é›œå°ç¨±åœ–å½¢";
                App.statusEl.innerText = msg; 
                App.renderToolbar(); 
                this.draw();
            },
            startDesign() { this.lines=[]; this.modeState='DESIGN'; this.axis={type:'V', pos:6}; App.statusEl.innerText="ç•«ç´…ç·šå‡ºé¡Œ"; App.renderToolbar(); this.draw(); },
            finishDesign() { if(!this.lines.some(l=>l.type===1)) return alert("è«‹ç•«ç·š"); this.modeState='PLAY'; App.statusEl.innerText="é–‹å§‹ä½œç­”"; App.renderToolbar(); this.draw(); },
            toggleAxis() { this.axis.type = this.axis.type==='V'?'H':'V'; this.draw(); },
            moveAxis() { this.axis.pos++; if(this.axis.pos>8) this.axis.pos=4; this.draw(); },
            toggleAnswer() { 
                this.showAnswer = !this.showAnswer;
                this.needsLoop = this.showAnswer; 
                App.renderToolbar();
                if(this.needsLoop) App.loop();
                else this.draw();
            },
            
            isQ(r,c) { return this.axis.type==='V' ? c < this.axis.pos : r < this.axis.pos; },
            getMirror(r,c) { 
                let mr, mc; 
                if(this.axis.type==='V') { mc=(this.axis.pos*2-1)-c; mr=r; } 
                else { mc=c; mr=(this.axis.pos*2-1)-r; } 
                if(mc<0||mc>=12||mr<0||mr>=12) return null; 
                return {r:mr, c:mc}; 
            },
            getDotPos(r,c) { const sp=(App.width-40)/11; return {x:20+c*sp, y:20+r*sp, sp}; },
            getNearest(x,y) { const sp=(App.width-40)/11; const c=Math.round((x-20)/sp), r=Math.round((y-20)/sp); if(c<0||c>=12||r<0||r>=12) return null; const px=20+c*sp, py=20+r*sp; if(Math.hypot(px-x, py-y)<sp*0.45) return {r,c,x:px,y:py}; return null; },

            addLine(l) { 
                const key = getLineUniqueKey(l.r1, l.c1, l.r2, l.c2);
                const idx = this.lines.findIndex(x => getLineUniqueKey(x.r1, x.c1, x.r2, x.c2) === key && x.type === l.type);
                if (idx >= 0) { this.lines.splice(idx, 1); } else { this.lines.push(l); }
            },

            onStart(pos) { if(this.modeState==='CHEAT_SETUP' || (this.showAnswer && this.modeState!=='CHEAT_PLAY')) return; const dot = this.getNearest(pos.x, pos.y); if(dot) { this.drag={active:true, r:dot.r, c:dot.c, cx:pos.x, cy:pos.y}; this.draw(); } },
            onMove(pos) { if(this.drag.active) { this.drag.cx=pos.x; this.drag.cy=pos.y; this.draw(); } },
            onEnd() {
                if(this.drag.active) {
                    const end = this.getNearest(this.drag.cx, this.drag.cy);
                    if(end && (end.r!==this.drag.r || end.c!==this.drag.c)) {
                        const type = this.modeState==='DESIGN' ? 1 : 2;
                        this.addLine({r1:this.drag.r, c1:this.drag.c, r2:end.r, c2:end.c, type}); 
                        if(this.modeState==='CHEAT_PLAY') { 
                            const m1=this.getMirror(this.drag.r, this.drag.c), m2=this.getMirror(end.r, end.c); 
                            if(m1 && m2) this.addLine({r1:m1.r, c1:m1.c, r2:m2.r, c2:m2.c, type}); 
                        } 
                    } 
                    this.drag.active=false; this.draw();
                }
            },

            draw() {
                const ctx=App.ctx, w=App.width, h=App.height; ctx.clearRect(0,0,w,h); const {sp} = this.getDotPos(0,0);
                
                // è»¸ç·š
                ctx.strokeStyle='#00ffc4'; ctx.lineWidth=3; ctx.shadowBlur=10; ctx.shadowColor='#00ffc4'; ctx.beginPath(); 
                if(this.axis.type==='V') { const x=20+(this.axis.pos-0.5)*sp; ctx.moveTo(x,0); ctx.lineTo(x,h); } 
                else { const y=20+(this.axis.pos-0.5)*sp; ctx.moveTo(0,y); ctx.lineTo(w,y); } 
                ctx.stroke(); ctx.shadowBlur=0;

                const drawLine = (l, color, width=4, shadowBlur=0) => {
                    const p1={x:20+l.c1*sp, y:20+l.r1*sp}, p2={x:20+l.c2*sp, y:20+l.r2*sp}; 
                    ctx.strokeStyle = color; ctx.lineWidth=width; ctx.shadowBlur = shadowBlur; ctx.shadowColor = color;
                    ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke(); ctx.shadowBlur = 0;
                };

                // ç¹ªè£½ä¸€èˆ¬ç·šæ®µ
                this.lines.forEach(l => { 
                    let c = (l.type===1 ? '#ff33cc' : '#33ccff');
                    drawLine(l, c); 
                });

                // å‘¼å¸ç‡ˆç­”æ¡ˆé¡¯ç¤º (Visual Comparison)
                // [MODIFIED] Added explicit check for DotsRaceMode's REVIEW state to force showAnswer logic
                if((this.showAnswer || (App.mode === 'DOTS_RACE' && DotsRaceMode.state === 'REVIEW')) && this.modeState!=='DESIGN') {
                    const time = Date.now();
                    const pulse = (Math.sin(time / 300) + 1) / 2; // 0 ~ 1
                    const alpha = 0.4 + pulse * 0.6; // 0.4 ~ 1.0
                    const blur = 5 + pulse * 15; // 5 ~ 20px
                    const goldColor = `rgba(255, 215, 0, ${alpha})`;

                    this.lines.filter(l=>l.type===1).forEach(q=>{ 
                        const m1=this.getMirror(q.r1,q.c1), m2=this.getMirror(q.r2,q.c2); 
                        if(m1&&m2) { 
                            // ç¹ªè£½é‡‘è‰²ç²—é«”å‘¼å¸ç·šæ®µ
                            const ansLine = {r1:m1.r, c1:m1.c, r2:m2.r, c2:m2.c};
                            drawLine(ansLine, goldColor, 8, blur); 
                        } 
                    }); 
                }

                // æ‹–æ›³é è¦½
                if(this.drag.active) { 
                    const startX=20+this.drag.c*sp, startY=20+this.drag.r*sp; 
                    const snap=this.getNearest(this.drag.cx, this.drag.cy); 
                    ctx.strokeStyle= this.modeState==='DESIGN'?'#ff33cc':'#33ccff'; 
                    ctx.lineWidth=2; ctx.setLineDash([5,5]); 
                    ctx.beginPath(); ctx.moveTo(startX,startY); ctx.lineTo(snap?snap.x:this.drag.cx, snap?snap.y:this.drag.cy); ctx.stroke(); ctx.setLineDash([]); 
                }

                // é»é»
                ctx.fillStyle='#666'; for(let r=0;r<12;r++) for(let c=0;c<12;c++) { ctx.beginPath(); ctx.arc(20+c*sp, 20+r*sp, 3, 0, Math.PI*2); ctx.fill(); }
            }
        };

        /**
         * =========================================
         * NEW MODE 6: DOTS RACE
         * =========================================
         */
         const DotsRaceMode = {
            lines: [], axis: {type:'V', pos:6}, state: 'IDLE', // IDLE, PLAYING, REVIEW, WAITING_NEXT, FINISHED
            level: 1, maxLevels: 3, 
            accumulatedTime: 0, // Total playing time
            levelStartTime: 0, // Start time of current level
            drag: {active:false}, needsLoop: true,
            reviewEndTime: 0,
            
            init() { this.state = 'IDLE'; App.statusEl.innerText = "ç«¶è³½æ¨¡å¼ï¼šé€£çºŒå®Œæˆä¸‰é“æŒ‘æˆ°é¡Œ"; this.level=1; App.renderToolbar(); this.draw(); },
            
            start() { 
                this.level = 1; 
                this.accumulatedTime = 0;
                this.levelStartTime = Date.now();
                this.state = 'PLAYING'; 
                this.generateLevel();
                App.renderToolbar();
            },

            generateLevel() {
                // Reuse DotsMode logic but force "MEDIUM" difficulty roughly
                DotsMode.randomLevel.call(this, 'MEDIUM'); 
                this.needsLoop = true; 
                this.state = 'PLAYING'; 
                this.levelStartTime = Date.now(); // Reset level timer
                App.statusEl.innerText = `ç¬¬ ${this.level}/3 é—œï¼šç•«å‡ºå°ç¨±ç·šæ®µ`;
                App.renderToolbar();
            },
            
            // User clicks check, we enter review mode for 5 seconds
            check() {
                // Add current level time to accumulated time
                const duration = Date.now() - this.levelStartTime;
                this.accumulatedTime += duration;

                this.state = 'REVIEW';
                this.reviewEndTime = Date.now() + 5000; 
                this.showAnswer = true; // trigger visual gold lines
                App.statusEl.innerText = "è«‹è€å¸«æª¢æŸ¥ç­”æ¡ˆ (5ç§’å¾Œå‡ºç¾æŒ‰éˆ•)";
                App.renderToolbar();
            },

            updateLoop() {
                if(this.state === 'REVIEW') {
                    const remaining = Math.ceil((this.reviewEndTime - Date.now())/1000);
                    if(remaining <= 0) {
                        this.state = 'WAITING_NEXT'; // Switch to waiting state
                        App.statusEl.innerText = (this.level >= this.maxLevels) ? "å·²å®Œæˆï¼è«‹æŒ‰ã€Œå®Œæˆã€æŸ¥çœ‹æˆç¸¾" : "è«‹æŒ‰ã€Œé€²å…¥ä¸‹ä¸€é—œã€";
                        App.renderToolbar(); // Force button update
                    } else {
                        App.statusEl.innerText = `è«‹è€å¸«æª¢æŸ¥ç­”æ¡ˆ (å‰©é¤˜ ${remaining} ç§’)`;
                    }
                }
            },

            nextLevel() {
                this.showAnswer = false;
                this.level++;
                this.generateLevel();
            },

            finish() {
                this.state = 'FINISHED';
                App.showScore("æŒ‘æˆ°å®Œæˆ", `ç¸½ä½œç­”æ™‚é–“ï¼š${formatTime(this.accumulatedTime)}`);
                App.renderToolbar();
            },
            
            // Reuse DotsMode Interaction
            onStart: DotsMode.onStart,
            onMove: DotsMode.onMove,
            onEnd: DotsMode.onEnd,
            getMirror: DotsMode.getMirror,
            isQ: DotsMode.isQ,
            getDotPos: DotsMode.getDotPos,
            getNearest: DotsMode.getNearest,
            addLine: DotsMode.addLine,

            getToolbarHTML() {
                if(this.state === 'IDLE') return `<button class="tool-btn btn-race" onclick="DotsRaceMode.start()">ğŸ é–‹å§‹æŒ‘æˆ°</button>`;
                if(this.state === 'FINISHED') return `<button class="tool-btn btn-primary" onclick="DotsRaceMode.init()">ğŸ”„ é‡æ–°é–‹å§‹</button>`;
                if(this.state === 'REVIEW') return `<div style="text-align:center; color:#ffd700; font-weight:bold; padding:10px;">æª¢æŸ¥ä¸­...</div>`;
                
                if(this.state === 'WAITING_NEXT') {
                    if (this.level >= this.maxLevels) {
                        return `<button class="tool-btn btn-race" onclick="DotsRaceMode.finish()">ğŸ å®Œæˆ (æŸ¥çœ‹æˆç¸¾)</button>`;
                    } else {
                        return `<button class="tool-btn btn-action" onclick="DotsRaceMode.nextLevel()">â¡ï¸ é€²å…¥ä¸‹ä¸€é—œ</button>`;
                    }
                }

                // PLAYING State
                return `<button class="tool-btn btn-action" onclick="DotsRaceMode.check()">âœ… å®Œæˆæäº¤ (é€²å…¥æª¢æŸ¥)</button> <button class="tool-btn btn-danger" onclick="DotsRaceMode.generateLevel()">ğŸ—‘ï¸ æ¸…ç©ºé‡ä¾†</button>`;
            },

            draw() {
                // In Review mode, force showAnswer logic
                const originalShowAnswer = this.showAnswer;
                if(this.state === 'REVIEW' || this.state === 'WAITING_NEXT') this.showAnswer = true;
                
                // Reuse DotsMode draw
                DotsMode.draw.call(this);
                this.showAnswer = originalShowAnswer;

                // Logic Loop
                this.updateLoop();

                const ctx = App.ctx;
                // Draw Timer overlay
                let displayTime = this.accumulatedTime;
                if(this.state === 'PLAYING') {
                    displayTime += (Date.now() - this.levelStartTime);
                }

                if(this.state !== 'IDLE' && this.state !== 'FINISHED') {
                    ctx.save();
                    ctx.fillStyle = "rgba(0,0,0,0.6)";
                    ctx.fillRect(App.width - 220, 10, 210, 50);
                    ctx.strokeStyle = "#ff5e62";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(App.width - 220, 10, 210, 50);
                    
                    ctx.fillStyle = "#ff5e62";
                    ctx.font = "bold 30px Courier New";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(formatTime(displayTime), App.width - 115, 35);
                    ctx.restore();
                }
            }
         };

        /**
         * =========================================
         * MODE 4: MANDALA
         * =========================================
         */
        const MandalaMode = {
            segments: 8, strokes: [], currentStroke: [], isDrawing: false, neonState: 0, needsLoop: false, cheatMode: false,
            init() { this.reset(); }, cleanup() { this.neonState = 0; },
            reset() { this.strokes = []; this.neonState = 0; this.needsLoop = false; App.statusEl.innerText = "å‰µé€ ä½ çš„è¬èŠ±ç­’ï¼"; this.draw(); },
            getToolbarHTML() {
                let neonText = "ğŸŒˆ éœ“è™¹: é—œ", neonClass = "tool-btn btn-neon";
                if(this.neonState === 1) { neonText = "ğŸŒˆ éœ“è™¹: åŒæ­¥"; neonClass += " neon-active"; }
                else if(this.neonState === 2) { neonText = "ğŸŒˆ éœ“è™¹: ç¨ç«‹"; neonClass += " neon-active"; }
                return `<span style="font-size:0.8rem; color:#aaa; text-align:center;">é¡åƒæ•¸</span><div style="display:flex; gap:5px; width:100%;"><button class="tool-btn" style="padding:5px;" onclick="MandalaMode.setSeg(4)">4</button><button class="tool-btn" style="padding:5px;" onclick="MandalaMode.setSeg(8)">8</button><button class="tool-btn" style="padding:5px;" onclick="MandalaMode.setSeg(12)">12</button></div><button class="${neonClass}" onclick="MandalaMode.toggleNeon()">${neonText}</button><button class="tool-btn btn-danger" onclick="MandalaMode.clear()">ğŸ—‘ï¸ æ¸…é™¤</button>`;
            },
            setSeg(n) { this.segments = n; this.draw(); },
            toggleNeon() { 
                this.neonState = (this.neonState + 1) % 3; this.needsLoop = (this.neonState > 0); App.renderToolbar(); 
                App.statusEl.innerText = this.neonState===1 ? "éœ“è™¹æ¨¡å¼ï¼šå…¨é«”åŒæ­¥å‘¼å¸" : (this.neonState===2 ? "éœ“è™¹æ¨¡å¼ï¼šç¨ç«‹æ™‚é–“æµå‹•" : "æ™®é€šæ¨¡å¼");
                if(this.needsLoop) App.loop(); else this.draw();
            },
            clear() { this.strokes = []; this.draw(); },
            onStart(pos) { this.isDrawing = true; this.currentStroke = [pos]; },
            onMove(pos) { if (this.isDrawing) this.currentStroke.push(pos); },
            onEnd() { if(this.isDrawing) { this.isDrawing = false; this.strokes.push({ points: this.currentStroke, timestamp: Date.now() }); this.currentStroke = []; } },
            draw() {
                const ctx = App.ctx, w = App.width, h = App.height, cx = w/2, cy = h/2; ctx.clearRect(0, 0, w, h); const time = Date.now();
                ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1; const angleStep = (Math.PI * 2) / this.segments;
                for(let i=0; i<this.segments; i++) { ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + Math.cos(i*angleStep)*w, cy + Math.sin(i*angleStep)*w); ctx.stroke(); }
                const drawStroke = (pts, col, blur) => { if(pts.length<2) return; ctx.strokeStyle = col; ctx.lineWidth = 2; ctx.shadowColor = col; ctx.shadowBlur = blur; ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y); for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y); ctx.stroke(); ctx.shadowBlur = 0; };
                const renderRotated = (pts, timestamp) => {
                    let col = '#00ffc4', blur = 0;
                    if (this.neonState > 0) {
                        let hue = 0, blurVal = 0;
                        if (this.neonState === 1) { hue = (time / 20) % 360; blurVal = 10 + Math.sin(time / 200) * 8; } 
                        else if (this.neonState === 2) { hue = ((time / 20) + (timestamp / 10)) % 360; blurVal = 10 + Math.sin((time / 200) + (timestamp / 500)) * 8; }
                        col = `hsl(${hue}, 100%, 60%)`; blur = blurVal;
                    }
                    for (let i = 0; i < this.segments; i++) { ctx.save(); ctx.translate(cx, cy); ctx.rotate(i * angleStep); ctx.translate(-cx, -cy); drawStroke(pts, col, blur); ctx.translate(cx, cy); ctx.scale(1, -1); ctx.translate(-cx, -cy); drawStroke(pts, col, blur); ctx.restore(); }
                };
                this.strokes.forEach(s => renderRotated(s.points, s.timestamp)); if(this.currentStroke.length > 0) renderRotated(this.currentStroke, time);
            }
        };

        window.onload = () => App.init();
    </script>
</body>
</html>
